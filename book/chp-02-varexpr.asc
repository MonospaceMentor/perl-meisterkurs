== Arbeiten mit Daten [[cha:varexpr]]

In diesem Kapitel lernen Sie, wie Sie innerhalb eines Perl-Programms Daten verarbeiten können. Sie erfahren, wie Perl Daten in Variablen speichert und wie Sie gespeicherte Daten wieder abrufen können.


=== Datentypen

So viel steht fest: Jedes Perl-Programm wird Daten verarbeiten. Nun kann man jedoch unter ``Daten'' vielerlei verstehen: Sowohl die Zahl 103928 als auch der gesamte Inhalt des Reiseführers ``Per Anhalter durch die Galaxis'' sind letztlich Daten, aber sehr unterschiedlich in Art und Menge. Und unterschiedliche Daten muss man meistens auch unterschiedlich behandeln. Zum Beispiel kann man 17 von 31 subtrahieren, aber nicht das Wort ``Hallo'' von dem Wort ``Welt'' .

Damit eine Programmiersprache verschiedene Arten von Daten verwalten kann, gibt es das Konzept der indexterm:[Datentypen] Datentypen: abhängig vom Datentyp eines Werts oder einer Variablen werden diese unterschiedlich behandelt.


==== Zahlen und Zeichenketten

Der Computer speichert in seinem Inneren letztlich alle Daten als Zahlen. Bei ``103928'' kann er das direkt, beim ``Anhalter'' muss zunächst eine Abbildung stattfinden, bei der jedem Zeichen ein bestimmter Zahlencode zugeordnet wird. Danach ist auch der Reiseführer nur noch eine Folge von Zahlen. Natürlich wird der Aufwand dieser Zuordnung vom Computer übernommen und nicht der Entwicklerin aufgebürdet. Deshalb kennt Perl neben den Zahlen auch sogenannte indexterm:[Zeichenketten] ``Zeichenketten'', in der Fachsprache auch ``Strings footnote:[Nicht zu verwechseln mit der anderen, für viele Informatiker ebenso interessanten Bedeutung des Wortes. ;-)]'' genannt.

Wo ein Programm also numerische Operationen durchführen soll (angefangen von einer simplen Addition bis hin zu komplexen Berechnungen) werden Zahlendaten verwendet. Für die Speicherung von Texten hingegen kommen Zeichenketten zum Einsatz, die beliebige Zeichen in beliebiger Anzahl enthalten dürfen. Für beide Datentypen gibt es spezielle Perl-Anweisungen, die Werte des jeweiligen Typs verarbeiten können.

Zahlen können in Perl mit oder ohne Nachkommastellen gespeichert werden, ebenso mit oder ohne Vorzeichen. Das Dezimalkomma wird allerdings in englischer Schreibweise durch einen Punkt symbolisiert. Große Zahlen können Sie zusätzlich im wissenschaftlichen Exponentialformat angeben:

----
-12345
3.14159
-1.2E+10
----

Zeichenketten hingegen dienen der Speicherung von Textdaten, die gleichermaßen Buchstaben, Ziffern und Sonderzeichen enthalten können. Wie viele einzelne Zeichen eine Zeichenkette umfassen kann, ist in Perl grundsätzlich nicht beschränkt.

----
"Jochen Lillich"
'0815'
"Ein\nmehrzeiliger\nText"
----

Zeichenketten werden in Perl durch indexterm:[Hochkomma] Hochkommata
(Apostrophe) `'` oder Anführungszeichen `"` begrenzt, wobei sich die beiden Varianten im
Verhalten nicht völlig gleichen.

Nur Zeichenketten in Anführungszeichen können sogenannte indexterm:[Escape-Zeichen] ``Escape-Zeichen'' beinhalten, die durch
einen Backslash eingeleitet werden. Diese Zeichen haben eine besondere Wirkung
bei der Ausgabe der Zeichenkette:

----
print "Dieser Text\nist zweizeilig.\n";
----

Hier sind die wichtigsten Escape-Zeichen aufgeführt:

<table>
  <thead>
    <tr>
      <th>Escape-Zeichen</th>
      <th>Bedeutung</th>
    </tr>
  </thead>
  
  <tbody>
    <tr>
      <td style="width: 5em;                  text-align:center">`\n`</td>
      <td>Newline (Ausgabe wird am Anfang der         nächsten Zeile fortgesetzt)</td>
    </tr>
    <tr>
      <td style="width: 5em;                  text-align:center">`\t`</td>
      <td>Tabulator (Ausgabe wird beim nächsten         Tabstopp
        fortgesetzt)</td>
    </tr>
    <tr>
      <td style="width: 5em;                  text-align:center">`\r`</td>
      <td>Carriage Return, Wagenrücklauf (Cursor         wird an den Zeilenanfang versetzt)</td>
    </tr>
  </tbody>
</table>

Wie der vorangestellte Backslash bestimmten Zeichen eine Sonderbedeutung geben
kann, kann er umgekehrt den sogenannten indexterm:[Metazeichen]
``Metazeichen'', die von Haus aus eine Sonderbedeutung haben, diese wieder
nehmen. Wenn Sie zum Beispiel innerhalb einer durch Hochkommata begrenzten
Zeichenkette ein ebensolches Hochkomma als Textbestandteil einbauen wollen,
müssen sie es als Escape-Zeichen schreiben, ihm also einen Backslash
voranstellen. Ansonsten würde es ja das Ende der Zeichenkette signalisieren
und der anschließende Text zu einer Fehlermeldung führen. Für andere Zeichen
mit Sonderbedeutung wie das Dollarzeichen gilt dasselbe.

----
print "Und Gott sprach: \"Es werde Licht.\"";

$zahl = 4711;
print "Der Wert von \$zahl ist $zahl\n";
----

Innerhalb von Zeichenketten in Apostrophen werden, anders als bei
Anführungszeichen, weder Variableninhalte interpoliert noch Escape-Zeichen
berücksichtigt.

Zeichenketten können sich auch über mehrere Zeilen erstrecken. Mit anderen
Worten: Das abschließende Anführungszeichen muss nicht in der selben Zeile
stehen wir das einleitende. Jedes eingeschlossene Zeilenende wird dabei zum
Bestandteil der Zeichenkette, so als hätten Sie an dieser Stelle ein
Newline-Escape-Zeichen eingebaut.

Für die Fälle, in denen das Setzen der Apostrophe oder Anführungszeichen zu
umständlich erscheint, bietet Perl die sogenannten indexterm:[Quote]
``Quote-Operatoren'' an, die ebenfalls literale Zeichenketten definieren:

* `q(Hallo Welt)` entspricht `'Hallo Welt'`
* `qq(Hallo Welt)` entspricht `"Hallo Welt"`

Die in obigen Beispielen als Begrenzer fungierenden runden Klammern können bei
Bedarf auch durch geschweifte Klammern, den Schrägstrich `/`, das
Nummernzeichen `#`, den Klammeraffen `@`. So kann man Konflikte mit in der
Zeichenkette enthaltenen Zeichen vermeiden.

Eine Zeichenkette, die keine Zeichen enthält, verdient zwar ihren Namen nicht
so recht, ist aber durchaus valides Perl. Sie kann zum Beispiel in der Form
`''` geschrieben werden. Der indexterm:[Leerstring] Leerstring ist somit ein
valider Wert -- auch wenn er bei der Ausgabe auf dem Bildschirm
unsichtbar bleibt.


==== Typumwandlung

Ein einzelner, ``atomarer'' Wert kann in Perl entweder eine Zahl oder ein String sein. (Im Kapitel <a href="#cha:references" class="chapterref"></a> werden wir noch die ``Referenz'' als weiteren Typ kennenlernen, bleiben wir aber zunächst bei den ersten beiden.)

Sehr streng unterscheidet Perl diese beiden Typen nicht. Anders als bei
anderen Programmiersprachen sind sie jederzeit weitgehend austauschbar -- je nachdem, in welchem Kontext ein Wert verwendet wird, wird sein Typ automatisch in die passende Alternative konvertiert. Was da genau passiert, behandeln wir etwas später.

*Übung:*

    Welche ist die einfachste Art, um die Worte ``Perl'' und
    ``Linux'' mit 3 Leerzeilen Zwischenraum auszugeben?


==== Logische Werte [[sect:logische-werte]]

indexterm[Logische Werte] Logische Werte sind die Grundlage von
Entscheidungen, die innerhalb eines Programms gefällt werden müssen.  Es gibt
nur zwei logische Werte: ``wahr'' und ``falsch''. Sie können
sie auch als ``Ja'' und ``Nein'' interpretieren.

Hängt zum Beispiel der Programmablauf davon ab, ob eine Variable den Wert 0
enthält, programmieren Sie eine entsprechende Prüfung, deren Ergebnis entweder
``wahr'' ist (Variablenwert ist 0) oder ``falsch'' (Variablenwert ist ungleich
0). Aufgrund dieses Ergebnisses entscheidet das Programm anschließend, wie es
weiterarbeiten soll.

In anderen Programmiersprachen gibt es für die beiden Möglichkeiten die Werte `TRUE` und `FALSE`, Perl jedoch kennt für diese Werte keine
spezielle Syntax. In Perl wird ``wahr'' durch die Zahl 1 dargestellt,
für ``falsch'' steht der Zustand `undef`.

Umgekehrt ordnet der Perl-Interpreter allen Zahlen und Zeichenketten eine Bedeutung als logische Werte zu. Interpretiert er eine Zahl als logischen
Wert, so entspricht der Wert 0 dem Wert ``falsch'', alle anderen
Zahlen stehen für ``wahr''. Als ``wahr'' werden auch alle
nicht-leeren Zeichenketten interpretiert, lediglich der Leerstring `""` wird als ``falsch'' interpretiert. Dadurch
können Sie jeden beliebigen Wert als logischen Wert verwenden, um zum Beispiel
eine Bedingung zu formulieren.


=== Ausdrücke

Jedes Sprachkonstrukt, dem ein Wert zugeordnet werden kann, wird als
indexterm:[Ausdruck] ``Ausdruck'' bezeichnet. Die einfachsten Ausdrücke sind Literale, das sind ausgeschriebene Zahlen oder Zeichenketten. Ihr Wert ist sofort ersichtlich; dass `153` den Wert 153 hat, liegt auf der Hand. 

Beliebig komplexe Ausdrücke entstehen durch die Verknüpfung von Ausdrücken
durch Operatoren. Ein Beispiel hierfür sind die Grundrechenarten: die
Verknüpfung der Ausdrücke `3` und `7` durch den Additionsoperator `+` ergibt
einen Ausdruck mit dem Wert 10. Mit anderen (verständlicheren) Worten: der
Wert des Ausdrucks `3+7` ist 10.

Auch die meisten im Sprachkern von Perl eingebauten Anweisungen erzeugen bei
ihrer Ausführung einen Wert, der vom Programm als Ausdruck verstanden wird.
Eine Anweisung, deren Hauptzweck darin liegt, einen solchen Wert zu erzeugen,
wird auch als indexterm:[Funktion] ``Funktion'' bezeichnet. Diesen Begriff
kennen Sie wahrscheinlich ebenfalls aus der Mathematik, zum Beispiel von der
Sinus-Funktion, deren Wert abhängig vom verarbeiteten Winkel irgendwo zwischen
-1 und +1 liegt. Wie bei der Sinus-Funktion gibt es auch in Perl Funktionen,
die einen oder mehrere Eingangswerte, so genannte indexterm:[Argument]
``Argumente'' oder indexterm:[Parameter] ``Parameter'', entgegennehmen und
daraus ein Ergebnis ermitteln. Wie Sie zusätzlich zu den vordefinierten eigene
Funktionen programmieren können, lernen Sie in einem späteren Kapitel.



=== Variablen

Für die Daten, die ein Perl-Programm verarbeiten soll, benötigt es passende
Speicherplätze. Das Programm legt in ihnen Werte ab, liest diese wieder heraus
und kann sie auch verändern oder löschen. Deshalb wird ein solcher
Speicherbereiche als indexterm:[Variable] ``Variable'' bezeichnet. Jede
Variable ist durch einen indexterm:[Bezeichner] ``Bezeichner'' eindeutig zu
identifizieren; anders gesagt: jede Variable hat einen Namen.

*Übung:*

    Kennen Sie die Regeln für Bezeichner noch? Schauen Sie noch einmal weiter vorn nach. 


==== Variablentypen

Es gibt in Perl drei grundlegend unterschiedliche Arten von Variablen:
indexterm[Skalar] ``Skalar'', indexterm:[Array] ``Array'' und indexterm:[Hash] ``Hash''.

Ein einzelner Wert, sei es nun eine Zahl oder eine Zeichenkette, wird als
``Skalar'' bezeichnet. Eine Variable, die einen Skalar speichern kann, wird
daher als indexterm:[Variable, Skalare Variable] ``skalare Variable'' bezeichnet.

Man kann sich eine skalare Variable als eine Schublade vorstellen (wobei wir im Folgenden immer davon ausgehen werden, dass eine Schublade stets nur einen einzelnen Wert enthalten kann):

image:graphics/scalar.png[]

[source,perl]
----
$string = "Hallo Welt!";
print $string;
----

In diesem Beispiel wird einer skalaren Variablen, deren Namen immer ein Dollarzeichen vorangestellt wird, ein Wert in Form einer Zeichenkette zugewiesen. In der folgenden Anweisung wird der Inhalt der Variablen -- eben die vorige Zeichenkette -- auf den Bildschirm ausgegeben.

Im Laufe eines Programms darf eine skalare Variable ihren Datentyp auch ändern. Sie kann an einer Stelle eine Zahl speichern und an einer anderen eine Zeichenkette. Weil das aber schnell zu Verwirrung führen kann, ist das nicht empfehlenswert.

IMPORTANT: Entscheiden Sie sich einmal für den Typ, den eine skalare Variable
haben soll, und bleiben Sie dabei.

Ein skalarer Speicherplatz, dem noch kein Wert -- weder eine Zahl noch eine Zeichenkette -- zugeordnet wurde, ist in undefiniertem Zustand. Die Funktion `defined` liefert einen logischen Wert, der anzeigt, ob ihr Parameter definiert ist oder nicht.

Zusätzlich zu den Skalaren gibt es noch zwei Variablenarten, die unter einem Namen beliebig viele skalare Werte zusammenfassen können.  Wir werden sie in Kapitel <<cha:complexdata>> genau unter die Lupe nehmen, sie seien aber hier schon einmal vorgestellt:

* Ein *Array* besteht aus einer beliebig langen Reihe
skalarer Elemente. Jedes dieser Elemente wird durch einen fortlaufenden Index
eindeutig identifiziert.

Auch das *Hash* enthält beliebig viele skalare Werte. Diese haben aber keine
bestimmte Ordnung und werden statt durch einen Index durch eine Zeichenkette,
den so genannten Schlüssel, eindeutig identifiziert.

Beim Zugriff auf Variablen wird dem Bezeichner immer ein Zeichen, das
sogenannte indexterm:[Sigil] ``Sigil'', vorangestellt, das für den _Typ des
Ergebniswertes_ steht:

* Beim Zugriff auf skalare Werte (skalare Variable, Arrayelement,
  Hashelement): `$` vor dem Variablennamen
* Beim Zugriff auf eine Array-Variable als Ganzes: `@` vor
  dem Variablennamen
* Beim Zugriff auf eine Hash-Variable als Ganzes: `%` vor
  dem Variablennamen

CAUTION: Bei Perl-Anfängern schleicht sich leicht das Missverständnis ein, dass das Sigil den Typ der Variablen widerspiegelt. In Wirklichkeit geht es aber um den Typ des Wertes, das der Variablenzugriff ergeben wird. Symbolisiert wird also nicht der Typ der Variablen, sondern der Typ des abgerufenen Wertes footnote:[Inzwischen haben die Perl-Hüter eingesehen, dass das instinktive Verständnis, das Sigil mit dem Variablentyp zu verbinden, die sinnigere Ansicht ist. Perl 6 wird genau so funktionieren.].

Ein Beispiel: Während beim Zugriff auf ein Array als Ganzes das
`@`-Zeichen eingesetzt wird, ist beim Zugriff auf einzelne Elemente
des Arrays, die immer skalar sind, das Dollarzeichen angebracht.



==== Zuweisung von Werten

Um einer Variablen einen Wert zuzuweisen, wird der indexterm:[Operator, Zuweisungsoperator] Zuweisungsoperator `=` eingesetzt. Dabei wird links des Operators die Variable genannt und rechts der Ausdruck, dessen Wert die Variable annehmen soll.

[source,perl]
----
$name = "Jochen";
$alter = 36;
----

Ein Skalar, der bereits einen Wert trägt, kann wieder in den undefinierten Zustand versetzt werden, indem Sie ihm den Pseudowert indexterm:[undef] `undef` zuweisen.

Diesen und weitere Zuweisungsoperatoren werden wir später noch ausführlich
kennenlernen.

*Übung:*

  Schreiben Sie ein kleines Programm, das einer Variablen einen
  zweizeiligen Text zuweist und diese dann ausgibt.


==== Zugriff auf Variablen

Überall, wo innerhalb eines Ausdrucks eine Variable auftaucht, wird an dieser
Stelle ihr Wert eingesetzt, bevor der Ausdruck ausgewertet wird:

[source,perl]
----
$a = 3;
$b = 5;
$c = $a + $b;     # $c erhält den Wert 8
----

Innerhalb Zeichenketten, die durch Anführungszeichen begrenzt sind, werden
Variablen ebenfalls interpoliert, d.h. durch ihre Werte ersetzt:

[source,perl]
----
$name = 'Margit';
$gruss = "Hallo $name!";
----

Weil auf diese Weise aber schnell der Überblick verloren geht, was Variable
und was Text ist, rate ich von dieser Vermischung ab. Es gibt besser lesbare
Möglichkeiten, Variableninhalte in Zeichenketten einzubauen, allem voran den
weiter unten erklärten Verkettungsoperator.

Bei Zeichenketten, die durch Apostrophe begrenzt sind, werden Variablen
grundsätzlich nicht interpoliert. Dies bringt, zusammen mit dem Ignorieren der
Escape-Zeichen, dieser Schreibweise einen kleinen Geschwindigkeitsvorteil.
Wichtiger ist aber, dass hier das Dollarzeichen und der Backslash als ganz
normale Zeichen behandelt werden. Wenn Sie also verhindern wollen, dass diese
Zeichen unerwünschte Sonderfunktionen auslösen, verwenden Sie Apostrophe.



==== Geltungsbereich

Jede Variable hat eine bestimmte indexterm:[Lebensdauer] Lebensdauer. Diese reicht von ihrer Erzeugung bis hin zu dem Punkt, an dem sie vernichtet und ihr Speicherbereich wieder zur anderweitigen Nutzung frei gegeben wird. Während dieser Lebensdauer der Variablen -- man spricht von ihrem indexterm:[Geltungsbereich] ``Geltungsbereich'' -- kann über ihren Namen auf ihren Inhalt zugegriffen werden.

Im einfachsten Fall wird eine Variable dann erzeugt, wenn sie zum ersten Mal im Programm benutzt wird, und vernichtet, wenn das Programm endet. Beides passiert automatisch. Der Geltungsbereich von Variablen ist somit von Haus aus das gesamte Programm; man spricht von indexterm:[Variable, Globale Variable] ``globalen Variablen''.

In anderen Programmiersprachen muss die Einführung einer neuer Variablen
speziell angekündigt werden, Perl erledigt das einfach bei Bedarf.

[source,perl]
----
# Programmstart
...
# Variable "x" existiert bisher noch nicht
...
$x = 100;
# Variable "x" existiert jetzt
# und speichert den Wert 100
...
# Programmende; alle Variablen werden vernichtet
----

Perl tut offensichtlich alles, um uns das Arbeiten mit Variablen so einfach wie möglich zu machen. ``Ein neuer Variablen-Bezeichner? Ach, erzeugen wir einfach eine passende Variable!'' Das bedeutet aber auch, dass ein Tippfehler im Variablennamen nicht zu einer Fehlermeldung führt, sondern zur Geburt einer neuen Variable und zu einem unvorhergesehenen Verhalten unseres Programms. Es ist daher besser, wenn wir den Eifer unserer Programmiersprache von vornherein etwas dämpfen. Etwas weiter unten lernen Sie, wie das geht.

Innerhalb ihres Geltungsbereichs und Datentyps sind Variablennamen eindeutig. Das heisst: innerhalb des gleichen Geltungsbereiches kann es keine zwei skalare Variablen mit dem Namen `$adresse` geben.

Der Datentyp ist jedoch ein Unterscheidungsmerkmal. Deshalb ist die parallele Existenz einer skalaren Variablen `$preis` und einer Array-Variablen `@preis` möglich. Dass so etwas nicht zur Verständlichkeit eines Programms beiträgt, liegt hoffentlich auf der Hand!

Dabei muss aber ganz klar gesagt werden: Globale Variablen begünstigen Programmierfehler und verursachen mehr Aufwand bei der Entwicklung! Sobald ein Programm mehr als ein paar Zeilen hat, wird es Ihnen schwer fallen, zu überblicken, welche Bezeichner schon für Variablen verwendet wurden. Wollen Sie zum Beispiel ein Programm, das Sie schon lange nicht mehr gewartet oder gar frisch von einem anderen Entwickler geerbt haben, an einer kleinen Stelle erweitern und dabei eine neue Variable hinzufügen, können Sie die Folgen dieser Änderung kaum absehen. Sollte nämlich der Bezeichner, für den Sie sich entschieden haben, wider Erwarten im Programm doch bereits benutzt werden, werden Sie unter Umständen unerwartete Ergebnisse erhalten.

IMPORTANT: Geltungsbereich bedeutet Wirkungsbereich footnote:[Jedenfalls in den meisten Fällen.].

Es ist mühsam, jedes Mal den gesamten Quelltext nach Variablennamen zu durchforsten. Ideal ist es deshalb, wenn der Geltungsbereich -- und damit der Wirkungsbereich -- von Variablen so klein wie möglich ist. Und weil Perl praxisgerecht ist, bietet es auch die nötigen Mittel, um den Geltungsbereich einer Variablen einzuschränken. Diese ist dann nur noch in bestimmten, eingegrenzten Teilen des Programms bekannt und zugänglich. Man spricht von einer indexterm:[Variable, Lokale Variable] ``lokalen Variablen''.

Wie lautet denn die Syntax für lokale Variablen? Schaut man sich in der Perl-Dokumentation um, stößt man auch schnell auf das Schlüsselwort indexterm:[`local`] `local`, das vielversprechend aussieht. Machen wir mal einen Versuch!

[source,perl]
----
#!/usr/bin/perl

$myvar = 10;
print "myvar: $myvar\n";

{
	local $myvar = 20;
	print "myvar: $myvar\n";
}

print "myvar: $myvar\n";
----

Und tatsächlich scheint `local` genau die gewünschte Wirkung zu
erzielen:

----
$ perl local1.pl
myvar: 10
myvar: 20
myvar: 10
----

Innerhalb des Blocks, in dem die Variable als lokal deklariert wurde, kann sie
tatsächlich einen anderen Wert annehmen als im umliegenden Programm.

Wenn wir jedoch Perl ein wenig in die Karten schauen, stellen wir fest, dass
`local` nicht der Weisheit letzter Schluss ist. Der Interpreter macht
hier nicht mehr als bei der `local`-Anweisung den alten Wert der
betreffenden Variablen in einem Zwischenspeicher zu sichern, um ihn
schließlich nach der letzten Zeile des aktuellen Blocks wieder zu
restaurieren. Es handelt sich also nicht um eine neue Variable mit geringem
Geltungsbereich, sondern um die alte, globale -- nur mit einem temporär
veränderten Wert! Diese Veränderung wird beim Verlassen des Blocks, in dem
`local` eingesetzt wurde, rückgängig gemacht.

Nun werden wir etwas später aber lernen, wie man mitten aus einem Block heraus die Abarbeitung eines ganz anderen Blocks, eines so genannten ``Unterprogramms'', auslösen kann. Weil `local` nur den Wert einer Variablen ändert, aber nichts daran, dass sie global im gesamten Programm existiert, können wir damit auch nicht verhindern, dass ein Unterprogramm auf die Variable zugreift. Welchen Wert wird sie dort aber enthalten? Klar: den temporären Wert unserer nur vermeintlich lokalen Variable! Denn ihr ursprünglicher Wert wird schließlich erst am Ende des `local`-Blocks wiederhergestellt, und das wurde in diesem Szenario noch nicht erreicht.

Was wir eigentlich benötigen, ist eine Variable, die nicht nur übergangsweise
einen anderen Wert annehmen kann, sondern deren Lebensdauer wirklich auf einen
Block beschränkt ist, die wirklich nur in diesem Block ``lebt'': Nur
innerhalb dieses Blocks darf die Variable bekannt und ihr Inhalt zugänglich
sein.

Und natürlich kennt Perl solche Variablen; sie werden als indexterm:[Variable, Lexikalische Variable]  ``lexikalische Variablen'' bezeichnet. Wir müssen an unserem Programm nicht einmal viel ändern, sondern einfach `local` durch das Schlüsselwort indexterm:[`my`] `my` ersetzen. Das Ergebnis sehen Sie im Listing ``local2.pl''.

[source,perl]
----
#!/usr/bin/perl

$myvar = 10;
print "myvar: $myvar\n";

{
	my $myvar;
	$myvar = 20;
	print "myvar: $myvar\n";
}

print "myvar: $myvar\n";
----

Eine lexikalische Variable ist wirklich nur innerhalb der geschweiften Klammern bekannt, die den Teil des Programms mit der `my`-Deklaration umschließen. Anderswo im Programm wird der Zugriff mit ihrem Bezeichner nie zu dieser Variable, sondern höchstens zu einer anderen Variable des gleichen Namens führen, die dort heimisch ist.

IMPORTANT: Das automatische Erzeugen neuer Variablen erschwert die Vermeidung logischer Fehler und deshalb unterbinden wir es am besten von vornherein für das gesamte Programm.

Dazu reicht die Anweisung `use strict;` am Beginn des Programms. Nach diesem indexterm:[Pragma] Pragma -- so nennt man Anweisungen, die das Verhalten des Perl-Interpreters beeinflussen -- wird der Perl-Interpreter jede Variable, die nicht mittels `my` eingeführt wurde, mit einer Fehlermeldung ablehnen und das Programm abbrechen.

Und weil sich `use strict;` hervorragend mit `use warnings;` versteht, empfehle ich Ihnen, jedes Ihrer Programme mit folgenden Zeilen zu beginnen:

[source,perl]
----
#!/usr/bin/perl
#
# Kurzbeschreibung des Programms

use strict;
use warnings;
----

Mit diesen beiden Pragmata verhindern Sie zahlreiche Probleme, die durch Unachtsamkeit, fehlenden Überblick oder Tippfehler entstehen.

Wohlgemerkt kann auch eine lexikalische Variable global sein, nämlich dann, wenn ihre Deklaration nicht von einem Block umgeben ist:

[source,perl]
----
#!/usr/bin/perl

my $pi = 3.1416; # global

{
    my $radius = 10;                # lokal
    my $umfang = 2 * $pi * $radius; # lokal

    print "Radius: ", $radius, 
      " Umfang: ", $umfang, "\n";
}

# hier ist nur noch $pi bekannt
----


=== Operatoren

Ein indexterm:[Operator] Operator verknüpft Werte und erzeugt aus ihnen einen Ergebniswert. Sie kennen Operatoren bereits aus der ersten Schulklasse: der Operator `+` verknüpft zwei Werte und liefert als Ergebnis den Wert ihrer Addition. Perl kennt eine Vielzahl von Operatoren, die allesamt einen, zwei oder gar drei Werte, die ``Operanden'', verknüpfen und aus ihnen einen Ergebniswert ermitteln. Abhängig von der Zahl ihrer Operanden bezeichnet man Operatoren als ``unär'', ``binär'' oder ``ternär''.

In den folgenden Abschnitten werden die verschiedenen Gruppen von Operatoren,
die Perl kennt, beschrieben.



==== Arithmetische Operatoren

indexterm:[Arithmetische Operatoren] indexterm:[Operator, Arithmetischer Operator] Arithmetische Operatoren kennen Sie aus dem Mathematikunterricht in der Grundschule. Die Grundrechenarten sind zum Beispiel arithmetische Operationen. Hinzu kommen der Potenzoperator und der indexterm:[Modulo-Operator] indexterm:[Operator, Modulo] Modulo-Operator, der den Rest bei einer ganzzahligen Division ermittelt.

<table>
    
    <thead>
        <tr>
            <th>Operation</th>
            <th>Bedeutung</th>
        </tr>
    </thead>
    
    <tbody>
        
        <tr>
            <td>`$a + $b`</td>
            <td>Addition</td>
        </tr>

        <tr>
            <td>`$a - $b`</td>
            <td>Subtraktion</td>
        </tr>

        <tr>
            <td>`$a * $b`</td>
            <td>Multiplikation</td>
        </tr>
    
        <tr>
            <td>`$a / $b`</td>
            <td>Division</td>
        </tr>
    
        <tr>
            <td>`$a ** $b`</td>
            <td>Potenz</td>
        </tr>
    
        <tr>
            <td>`$a % $b`</td>
            <td>Modulo (Rest bei der Division)</td>
        </tr>
    
    </tbody>
    
</table>


==== Zuweisungsoperatoren

Das Gleichheitszeichen haben wir bereits als indexterm:[Operator, Zuweisungsoperator] Zuweisungsoperator kennengelernt. Bei der Zuweisung wird zuerst der Ausdruck auf der rechten Seite ausgewertet und das Ergebnis dann in der Variablen auf der linken Seite gespeichert.

[source,perl]
----
$username = "geewiz";
$op1 = 14;
$op2 = 211;
$summe = $op1 + $op2;
----

Die Zuweisung ist ebenfalls ein Ausdruck; der zugewiesene Wert der
rechten Seite ist gleichzeitig der Wert der Zuweisung als Ganzes.

Oft taucht die auf der linken Seite verwendete Variable auch rechts
wieder auf, weil ihr neuer Wert aus dem alten Wert ermittelt wird.
Zum Beispiel wird auf eine Summenvariable immer wieder ein neuer Wert
aufaddiert:

[source,perl]
----
$sum = $sum + $item;
----

Um solche Ausdrücke kürzer schreiben zu können, wurden zusätzliche
Zuweisungsoperatoren aus der Programmiersprache C übernommen:

[source,perl]
----
$var += 2;   # entspricht $var = $var + 2;
$var -= 2;   # entspricht $var = $var - 2;
$var *= 2;   # entspricht $var = $var * 2;
$var /= 2;   # entspricht $var = $var / 2;
----


==== Inkrement-/Dekrement-Operatoren

Zählen gehört zu den häufigsten Aufgaben innerhalb einer Software,
seien es die Zeilen einer Datei, die Zahl aufgezeichneter Basenpaare
oder die Worte eines Schulungsbuchs.

Deshalb hat Larry Wall seiner Programmiersprache spezielle Operatoren
hinzugefügt, die Variablenwerte um 1 erhöhen oder verringern.

[source,perl]
----
$var++;   # entspricht $var += 1;
$var--;   # entspricht $var -= 1;
----

Es handelt sich dabei sichtlich um ``unäre Operatoren'' -- sie beziehen sich auf den Bezeichner der zu verändernden Variable und benötigen keinen weiteren Operanden. Der Operator, der eine Variable um 1 erhöht, heißt indexterm:[Inkrement-Operator] indexterm:[Operator, Inkrement]  ``Inkrement-Operator'', der gegenteilige heißt indexterm:[Dekrement-Operator] indexterm:[Operator, Dekrement] ``Dekrement-Operator''.

Wie alle Operatoren bilden auch die Inkrement-/Dekrement-Operatoren einen
Ausdruck. Dabei stellt sich aber die folgende Frage: ermittelt sich der Wert
des Ausdrucks nun aus dem Zustand der Variablen vor der Veränderung oder dem
nach der Veränderung? Betrachten wir zum Beispiel folgendes Beispiel:

[source,perl]
----
$a = 5;
$doppelt = $a++ * 2;
----

Wird `$doppelt` den Wert 10 oder 12 enthalten?

Die Erfahrung zeigt, dass in der Praxis keine Alternative der anderen
überlegen ist. Daher gibt es von diesem Operator eine Variante, die _zuerst
die Variable verändert_ und dann ihren (neuen) Wert liefert, und eine, die
erst ihren Wert ermittelt und _die Variable erst danach verändert_.
Entsprechend steht der Operator dabei einmal _vor dem Bezeichner_ und
einmal _nach dem Bezeichner_.

[source,perl]
----
$a = 5;
$doppelt = ++$a * 2;
# $a ist jetzt 6, $doppelt ist 12 

$a = 5;
$doppelt = $a++ * 2;
# $a ist jetzt 6, $doppelt ist 10 
----


==== Vergleichsoperatoren

indexterm:[Vergleich] Wo immer Daten verarbeitet werden, werden sie
untereinander verglichen. Und auf Basis dieser Vergleiche werden dann
Entscheidungen über die weitere Verarbeitung getroffen.

Perl steuert zu diesem Zweck indexterm:[Vergleichsoperatoren] indexterm:[Operator, Vergleich] Vergleichsoperatoren bei, die einen logischen Wert annehmen, der den Ausgang des Vergleichs darstellt (``ist kleiner als'', ``ist größer oder gleich'', usw.).

_Zahlen_ zu vergleichen fällt Perl ähnlich leicht wie uns Menschen. Zu
entscheiden, welche von zwei Zahlen die größere ist -- vorausgesetzt, sie
sind nicht gleich -- erfordert nicht viel Diskussion.

_Zeichenketten_ werden immer zeichenweise von links her so lange verglichen,
bis eine Entscheidung möglich ist. Verglichen werden die Zeichencodes,
innerhalb derer Ziffern und Buchstaben natürlich in der gewohnten Reihenfolge
auftreten. Sobald sich beim Vergleich zweier Zeichen ein Unterschied ergibt,
bestimmt dieser das Ergebnis des Vergleichs. Wurden alle Zeichen verglichen,
ohne dass sich ein Unterschied ergab, sind beide Zeichenketten offensichtlich
gleich. Bleiben von einer der beiden Zeichenketten noch Zeichen übrig, wird
sie als größer betrachtet. Durch dieses Verfahren entsteht aber folgende
skurrile Situation:

* `1`  ist kleiner als `2`. Klar.
* `10` ist größer als `2`. Auch hier gilt unsere Schulmathematik.
* `"1"` ist kleiner als `"2"`, weil auch im Zeichencode die 1 vor der 2 kommt.
* `"10"` ist *kleiner* als `"2"`! Da schon die jeweils ersten Zeichen unterschiedlich sind, wird auch bereits hier der Vergleich mit der Erkenntnis des vorangehenden Punkts beendet.

Was passiert denn aber nun, wenn ich eine Zahl mit einer Zeichenkette
vergleiche -- vor allem angesichts der automatischen Datenwandlung des
Interpreters? Um hier Eindeutigkeit zu schaffen, hat man Perl gleich zwei
Sätze von Vergleichsoperatoren verliehen -- einen für Zahlen, einen für
Strings:

<table>
    <thead>
        <tr>
            <th>Vergleich von Zahlen</th>
            <th>Vergleich von Strings</th>
            <th>Bedeutung</th>
        </tr>
    </thead>
    
    <tbody>
        
        <tr>
            <td>`==`</td>
            <td>`eq`</td>
            <td>ist gleich</td>
        </tr>
                
        <tr>
            <td>`!=`</td>
            <td>`ne`</td>
            <td>ist ungleich</td>
        </tr>
                
        <tr>
            <td>`<`</td>
            <td>`lt`</td>
            <td>ist kleiner als</td>
        </tr>
                
        <tr>
            <td>`>`</td>
            <td>`gt`</td>
            <td>ist größer als</td>
        </tr>
                
        <tr>
            <td>`<=`</td>
            <td>`le`</td>
            <td>ist kleiner oder gleich</td>
        </tr>
                
        <tr>
            <td>`>=`</td>
            <td>`ge`</td>
            <td>ist größer oder gleich</td>
        </tr>

    </tbody>
</table>


==== Auswahloperator

Der indexterm:[Operator, Auswahloperator] Auswahloperator ist der einzige indexterm:[Operator, Ternärer Operator] ``ternäre Operator'' in Perl, also der einzige Operator, der drei Operanden hat. Der erste Operator ist dabei ein logischer Ausdruck in runden Klammern, dem ein Fragezeichen und zwei durch einen Doppelpunkt getrennte beliebige Ausdrücke folgen.

[source,perl]
----
$result = ( $a == $b ) ? "gleich" : "ungleich"
----

Der Wert der Operation hängt nun von dem logischen Ausdruck ab: hat dieser den Wert ``wahr'', nimmt der Gesamtausdruck den Wert des zweiten Operanden an, ansonsten den des dritten.

Somit macht es der Auswahloperator möglich, von Bedingungen abhängige Ausdrücke zu formulieren.

Weil auch Kommandos Ausdrücke sind, ist auch folgendes Konstrukt möglich:

[source,perl]
----
( $a == $b ) ? print "gleich" : print "ungleich";
----

Besserer Stil, weil leichter lesbar, ist es jedoch, die Auswahloperation wirklich als Ausdruck ernst zu nehmen und ihr Ergebnis sinnvoll zu verwenden:

[source,perl]
----
print ( ( $a == $b ) ? "gleich" : "ungleich" );
----

Die umgebenden Klammern verhindern, dass der Interpreter dem Ausdruck `print ($a == $b)` Priorität vor dem Auswahloperator verleiht.


==== Logische Operatoren

Um logische Ausdrücke zu komplexeren, wiederum logischen Ausdrücken zusammensetzen zu können, brauchen wir indexterm:[Operator, Logischer Operator] logische Operatoren. Diese werden durch die so genannte indexterm:[Boolesche Algebra] ``Boolesche Algebra'' definiert, benannt nach dem Mathematiker Boole. 

Sie kennt als Operationen die indexterm:[Und-Verknüpfung] Und-Verknüpfung (indexterm:[AND] ``AND''), die indexterm:[Oder-Verknüpfung] Oder-Verknüpfung (indexterm:[OR] ``OR''), die indexterm:[Exklusiv-Oder-Verknüpfung] Exklusiv-Oder-Verknüpfung (indexterm:[XOR] ``XOR'') sowie die indexterm:[Negation] Negation (indexterm:[NOT] ``NOT''). Mit Ausnahme der Negation wird bei jeder dieser Operationen mit zwei Werten gearbeitet.

Die Negation hat nur einen Operanden, dessen Wert logisch ins
Gegenteil verkehrt wird. Ist der Operand also der Zahlenwert 0, die
leere Zeichenkette `""` oder `undef`, so ergibt die
Negation den Wert 1 (logisch ``wahr''). Die Negation aller anderen
Werte ergibt einen Nullwert.

Die AND-Verknüpfung ist nur dann ``wahr'', wenn auch beide
Operanden ``wahr'' sind. Perl kennt für diese Operation den
Operator `&`.

<table>
    <thead>
        <tr>
            <th>AND</th>
            <th>wahr</th>
            <th>falsch</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="col1">wahr</td>
            <td>wahr</td>
            <td>falsch</td>
        </tr>
        <tr>
            <td class="col1">falsch</td>
            <td>falsch</td>
            <td>falsch</td>
        </tr>
    </tbody>
</table>

Bei der OR-Verknüpfung, in Perl durch den Operator `||` symbolisiert, reicht es, wenn einer der beiden Operanden ``wahr'' ist:

<table>
    <thead>
        <tr>
            <th>OR</th>
            <th>wahr</th>
            <th>falsch</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="col1">wahr</td>
            <td>wahr</td>
            <td>wahr</td>
        </tr>
        <tr>
            <td class="col1">falsch</td>
            <td>wahr</td>
            <td>falsch</td>
        </tr>
    </tbody>
</table>


Die XOR-Verknüpfung (Operator: `^`) erwartet, dass nur einer der beiden Operanden ``wahr'' ist:

<table>
    <thead>
        <tr>
            <th>XOR</th>
            <th>wahr</th>
            <th>falsch</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="col1">wahr</td>
            <td>falsch</td>
            <td>wahr</td>
        </tr>
        <tr>
            <td class="col1">falsch</td>
            <td>wahr</td>
            <td>falsch</td>
        </tr>
    </tbody>
</table>

Perl hat auch hier zwei Sätze von Operatoren. Beim einen werden die Operatoren durch Sonderzeichen dargestellt, beim anderen sind es die englischsprachigen Bezeichnungen, die oben bereits genannt wurden. Der Unterschied liegt in der Rangfolge innerhalb der Menge der Operatoren: die erstgenannten Varianten haben einen sehr hohen Rang, diese Operationen werden also schon sehr früh ausgewertet; die ausgeschriebenen Operatoren hingegen liegen in der Rangfolge sehr weit hinten und lassen den meisten anderen Operationen den Vortritt. Diese Unterscheidung erspart uns oftmals das Einklammern von Teilausdrücken.



==== Logischer Kurzschluss

In C liefern die logischen Operatoren auch tatsächlich reine Wahrheitswerte, nämlich 0 oder 1. Perl macht es sich hier einfacher. Das Ergebnis der logischen Verknüpfung wird in Perl nämlich durch ein sogenanntes indexterm:[Logischer Kurzschluss] ``Kurzschlussverfahren'' ermittelt. Dabei macht man sich die Tatsache zunutze, dass sowohl bei AND als auch bei OR in einer der beiden Spalten der Wert des zweiten Operanden erhalten bleibt. Und so gilt in Perl schlicht und einfach:

* Ist bei der AND-Verknüpfung der erste Operand logisch ``wahr'',
  ergibt die Operation den Wert des zweiten Operanden, ansonsten den
  des ersten.
* Ist bei der OR-Verknüpfung der erste Operand logisch ``falsch'',
  ergibt die Operation den Wert des zweiten Operanden, ansonsten den
  des ersten.

So lange Sie mit reinen logischen Werten (also 0 oder 1) arbeiten, entspricht dieses Verhalten exakt den oben dargestellten Tabellen.

Flexibel, wie Perl ist, dürfen die Werte der Operanden jedoch beliebige Ausdrücke sein. Da es klare Regeln gibt, welche Werte als logisch ``falsch'' angesehen werden (nämlich 0, die leere Zeichenkette und `undef`; siehe Kapitel <<sect:logische-werte,Logische Werte>>), werden die Operanden bei der Verknüpfung nicht in logische Werte umgewandelt, sondern nur als solche interpretiert. Es ergibt sich aus der Verknüpfung also einer der Originalwerte der Operanden.

*Übung*

	Welche Werte haben die folgenden Ausdrücke?
	
	* `0 and 1`
	* `'x' or 'u'`
	* `1 and 0`
	* `0 or 'NULL'`

Das ermöglicht es uns zum Beispiel, ganz einfach einer Variablen einen Standardwert zuzuweisen, falls sie noch leer ist. `undef` wird bekanntlich als ``falsch'' gewertet, sodass wir uns das eben beschriebene Verhalten der OR-Verknüpfung zunutze machen können:

[source,perl]
----
$a = $a || 'vormals undefiniert';

# kuerzer:
$a ||= 'vormals undefiniert';
-----

Perl in seiner nahezu grenzenlosen Flexibilität erlaubt es uns außerdem,
Anweisungen als Operanden einzusetzen. Für Perl hat jede Anweisung einen Wert
(im Zweifel den Wert ``wahr''), sodass sie in Ausdrücken, auch in
logischen, eingesetzt werden darf.

Oben beschriebene Logik, nach der Perl zunächst den linken Operanden
betrachtet und dann entscheidet, ob der rechte überhaupt noch interessant ist,
eröffnet uns die Möglichkeit, Anweisungen bedingt auszuführen, ohne eine dafür
ausgelegte Anweisung zu benutzen.

Bei der AND-Verknüpfung spielt der rechte Operand nur dann eine Rolle, wenn
der linke den Wert ``wahr'' hat; ansonsten steht das Ergebnis der
Operation schon fest -- ``falsch''. Der Perl-Interpreter ist schlau
genug, den zweiten Operanden also nur dann auszuwerten, wenn der erste
``wahr'' ist.

Umgekehrt wird Perl den rechten Operanden einer OR-Verknüpfung nur dann
auswerten, wenn der linke ``falsch'' ist, denn nur dann hängt das
Ergebnis vom rechten Operanden ab.

Und jetzt kommt der Trick: setzen wir als linken Operanden einen logischen
Ausdruck, als rechten Operanden aber eine Anweisung ein, hängt deren
<em>Ausführung</em> vom linken Operanden, der Bedingung, ab: bei AND wird die
Anweisung nur ausgeführt, wenn sie ``wahr'' ist, und bei der
OR-Verknüpfung führt nur ein ``falsch'' zur Ausführung der Anweisung.

[source,perl]
----
( $a == 1 ) && print "a == 1!\n";
( $a == 1 ) || print "a != 1!\n";
-----


==== Bitbearbeitungsoperatoren

Zahlen werden im Rechner bekanntlich in Form von Bits und Bytes gespeichert. Um auf dieser Ebene Berechnungen durchzuführen, werden Operatoren benötigt, die einzelne Bits in einem Wert modifizieren können.

Nun sind Bits mit ihren digitalen Werten 1 und 0 nicht viel anders als die vorhin beschriebenen logischen Werte ``wahr'' und ``falsch''. Operationen wie die Und-Verknüpfung und ihre Kollegen können zunächst auf einzelne Bits angewandt werden, dann aber auch auf ganze Bitfolgen und ein Byte ist nichts anderes als eine Folge von 8 Bits. Es werden einfach Bit für Bit miteinander ausgewertet.

In der Praxis geht es hauptsächlich um das Setzen und Löschen bestimmter Bits in einem Binärwert. Es gilt, diesen Ausgangswert durch eine logische Verknüpfung mit einem passend gewählten zweiten Wert, der sogenannten Bitmaske, zu manipulieren.

Schaut man sich die verfügbaren logischen Operationen genauer an, findet man schnell heraus, dass die Und-Verknüpfung mit einem 0-Bit unabhängig vom Zustand des Ausgangsbits unweigerlich zu einem 0-Bit im Ergebnis führt. Das betreffende Bit im Ausgangswert wird also gelöscht. Ein 1-Bit hingegen lässt das verknüpfte Bit im Ausgangswert unverändert.

----
    01001100
AND 10000111
____________
    00000100
----

Umgekehrt ist es mit der Oder-Verknüpfung: eine 1 führt unweigerlich zu einer 1 im Ergebnis, während eine 0 das ursprünglich Bit unverändert durchlässt.

----
     01001100
OR   10000111
_____________
     11001111
----

Diese Bit-Operationen werden durch die indexterm:[Operator, Bitbearbeitungs-Operator] Bitbearbeitungs-Operatoren `&` (AND) und `|` (OR) durchgeführt.


==== Zeichenkettenoperatoren

Die Anzahl der Operatoren für indexterm:[Operator, Zeichenkettenoperator] Zeichenketten ist sehr überschaubar. Da wäre zum einen der indexterm:[Operator, Verkettungsoperator] Verkettungsoperator `.` zu nennen, der zwei Strings zu einem zusammenschweisst:

[source,perl]
----
$name = "Jochen";
$output = "Hallo " . $name . "!\n";
print $output;
----

Der zweite Operator ist etwas ungewöhnlicher, es gibt ihn in kaum einer anderen Programmiersprache außer Perl. Es handelt sich um den String-Vervielfacher `x`. Er hat als Operanden einen String und eine Zahl n. Das Ergebnis ist eine Zeichenkette, die aus n Wiederholungen des Eingangsstrings besteht.

[source,perl]
----
$trenner = "---8<--- ";
print $trenner x 5, "\n";
----

	
==== Rangfolge

Aus der Schule ist die Regel ``Punkt vor Strich'' bekannt. Sie besagt,
dass die Operatoren für Multiplikation und Division Vorrang vor denen für
Addition und Subtraktion haben.

Eine solche Rangfolge gilt für alle Operatoren einer Programmiersprache. Setzt
man Perl einen komplexen Ausdruck vor, entscheidet der Interpreter anhand der
definierten Ränge, in welcher Reihenfolge die einzelnen Operationen ausgeführt
werden. Zuerst kommen die höher rangierenden Operationen, erst danach werden
die Operatoren mit niedrigerem Rang berücksichtigt. Gleichrangige Operationen
werden der Reihe nach von links nach rechts ausgeführt.

Wie in der Mathematik kann auch in Perl-Ausdrücken durch das Setzen runder
Klammern von der vorgegebene Rangfolge von Operatoren abgewichen werden.

Die genaue Rangfolge (engl. ``precedence'') der Perl-Operatoren können
Sie der man-Page `perlop` entnehmen.


=== Gürtelprüfung

image::image/judogi.jpg[width=200]

Damit sind wir am Ende des ersten Lernabschnitts, der Sie in grundlegende
Eigenschaften von Perl eingeführt hat. Sie wissen nun, was Variablen sind und
wie Sie sie einsetzen können.

Der erste farbige Gürtel steht Ihnen zu, wenn Sie die folgenden Fragen und
Übungen erfolgreich absolvieren können. Für Schüler des 8. Kyu ist dieser
gelb.

*Übung*

1. Welche Typen von Variablen gibt es, und wie unterscheiden sie sich?
2. Was müssen Sie beim Geltungsbereich von Variablen beachten, und
  wie können Sie ihn verändern?
3. Wie erklären Sie die Begriffe ``Ausdruck'' und ``Operator''?
4. Was sind die Unterschiede zwischen den Vergleichsoperatoren für Zahlen
und denen für Zeichenketten? Auf was müssen Sie hier achten?

	
*Übung*

Bearbeiten Sie den folgenden Ausschnitt aus einem Perl-Programm. (Für die
Nachbesprechung sind die Zeilennummern angegeben.) Geben Sie jeweils das zu
erwartende Ergebnis der Ausdrücke an.

[source,perl]
----
01:  $a=220; $b=11; $c=8; $string1="Hallo"; $string2="Welt";
02:  $ergebnis = $b * $c;
03:  $ergebnis = $b - $string2;
04:  $d = $c . $string1;
05:  $ergebnis = $b * $d;
06:  $ergebnis = $a % $c;
07:  $ergebnis = $b & $c;
08:  $ergebnis = $a / ––$b;
09:  $ergebnis = $string1 . $string2;
10:  $ergebnis = $string2 x 2;
11:  $ergebnis = ($b <= ($c + 2 + $b));
12:  $ergebnis = ($string1 eq $b);
13:  $b += 9;
----

*Übung*

1. Programmieren Sie einen möglichst kurzen Einzeiler, der den Text
``Hallo Welt!'' zwischen zwei Folgen von je 10 Sternchen ausgibt.
2. Schreiben Sie ein möglichst kurzes Programm, das die Variable
`$i` zunächst auf den Wert 5 setzt und dann dreimal um 1 erhöht. Das
Ergebnis jeder Veränderung soll auf dem Bildschirm angezeigt werden.
3. Bauen Sie eine Perl-Anweisung, die ``NULL'' auf den
Bildschirm ausgibt, wenn der Wert einer Variablen `$anzahl` gleich 0
ist. In jedem anderen Fall soll ihr Wert ausgegeben werden.
