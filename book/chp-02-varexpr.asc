== Arbeiten mit Daten

In diesem Kapitel lernen Sie, wie Sie innerhalb eines Perl-Programms Daten verarbeiten können. Sie erfahren, wie Perl Daten in Variablen speichert und wie Sie gespeicherte Daten wieder abrufen können.


=== Datentypen

So viel steht fest: Jedes Perl-Programm wird Daten verarbeiten. Nun kann man jedoch unter ``Daten'' vielerlei verstehen: Sowohl die Zahl 103928 als auch der gesamte Inhalt des Reiseführers ``Per Anhalter durch die Galaxis'' sind letztlich Daten, aber sehr unterschiedlich in Art und Menge. Und unterschiedliche Daten muss man meistens auch unterschiedlich behandeln. Zum Beispiel kann man 17 von 31 subtrahieren, aber nicht das Wort ``Hallo'' von dem Wort ``Welt''.

Damit eine Programmiersprache verschiedene Arten von Daten verwalten kann, gibt es das Konzept der indexterm::[Datentypen] Datentypen: abhängig vom Datentyp eines Werts oder einer Variablen werden diese unterschiedlich behandelt.


==== Zahlen und Zeichenketten

Der Computer speichert in seinem Inneren letztlich alle Daten als Zahlen. Bei ``103928'' kann er das direkt, beim ``Anhalter'' muss zunächst eine Abbildung stattfinden, bei der jedem Zeichen ein bestimmter Zahlencode zugeordnet wird. Danach ist auch der Reiseführer nur noch eine Folge von Zahlen. Natürlich wird der Aufwand dieser Zuordnung vom Computer übernommen und nicht der Entwicklerin aufgebürdet. Deshalb kennt Perl neben den Zahlen auch sogenannte indexterm:[Zeichenketten] ``Zeichenketten'', in der Fachsprache auch ``Strings footnote:[Nicht zu verwechseln mit der anderen, für viele Informatiker ebenso interessanten Bedeutung des Wortes. ;-)]'' genannt.

Wo ein Programm also numerische Operationen durchführen soll (angefangen von einer simplen Addition bis hin zu komplexen Berechnungen) werden Zahlendaten verwendet. Für die Speicherung von Texten hingegen kommen Zeichenketten zum Einsatz, die beliebige Zeichen in beliebiger Anzahl enthalten dürfen. Für beide Datentypen gibt es spezielle Perl-Anweisungen, die Werte des jeweiligen Typs verarbeiten können.

Zahlen können in Perl mit oder ohne Nachkommastellen gespeichert werden, ebenso mit oder ohne Vorzeichen. Das Dezimalkomma wird allerdings in englischer Schreibweise durch einen Punkt symbolisiert. Große Zahlen können Sie zusätzlich im wissenschaftlichen Exponentialformat angeben:

----
-12345
3.14159
-1.2E+10
----

Zeichenketten hingegen dienen der Speicherung von Textdaten, die gleichermaßen Buchstaben, Ziffern und Sonderzeichen enthalten können. Wie viele einzelne Zeichen eine Zeichenkette umfassen kann, ist in Perl grundsätzlich nicht beschränkt.

----
"Jochen Lillich"
'0815'
"Ein\nmehrzeiliger\nText"
----

Zeichenketten werden in Perl durch indexterm:[Hochkomma] Hochkommata
(Apostrophe) `'` oder Anführungszeichen `"` begrenzt, wobei sich die beiden Varianten im
Verhalten nicht völlig gleichen.

Nur Zeichenketten in Anführungszeichen können sogenannte indexterm:[Escape-Zeichen] ``Escape-Zeichen'' beinhalten, die durch
einen Backslash eingeleitet werden. Diese Zeichen haben eine besondere Wirkung
bei der Ausgabe der Zeichenkette:

----
print "Dieser Text\nist zweizeilig.\n";
----

Hier sind die wichtigsten Escape-Zeichen aufgeführt:

<table>
  <thead>
    <tr>
      <th>Escape-Zeichen</th>
      <th>Bedeutung</th>
    </tr>
  </thead>
  
  <tbody>
    <tr>
      <td style="width: 5em;                  text-align:center">`\n`</td>
      <td>Newline (Ausgabe wird am Anfang der         nächsten Zeile fortgesetzt)</td>
    </tr>
    <tr>
      <td style="width: 5em;                  text-align:center">`\t`</td>
      <td>Tabulator (Ausgabe wird beim nächsten         Tabstopp
        fortgesetzt)</td>
    </tr>
    <tr>
      <td style="width: 5em;                  text-align:center">`\r`</td>
      <td>Carriage Return, Wagenrücklauf (Cursor         wird an den Zeilenanfang versetzt)</td>
    </tr>
  </tbody>
</table>

Wie der vorangestellte Backslash bestimmten Zeichen eine Sonderbedeutung geben
kann, kann er umgekehrt den sogenannten indexterm:[Metazeichen]
``Metazeichen'', die von Haus aus eine Sonderbedeutung haben, diese wieder
nehmen. Wenn Sie zum Beispiel innerhalb einer durch Hochkommata begrenzten
Zeichenkette ein ebensolches Hochkomma als Textbestandteil einbauen wollen,
müssen sie es als Escape-Zeichen schreiben, ihm also einen Backslash
voranstellen. Ansonsten würde es ja das Ende der Zeichenkette signalisieren
und der anschließende Text zu einer Fehlermeldung führen. Für andere Zeichen
mit Sonderbedeutung wie das Dollarzeichen gilt dasselbe.

----
print "Und Gott sprach: \"Es werde Licht.\"";

$zahl = 4711;
print "Der Wert von \$zahl ist $zahl\n";
----

Innerhalb von Zeichenketten in Apostrophen werden, anders als bei
Anführungszeichen, weder Variableninhalte interpoliert noch Escape-Zeichen
berücksichtigt.

Zeichenketten können sich auch über mehrere Zeilen erstrecken. Mit anderen
Worten: Das abschließende Anführungszeichen muss nicht in der selben Zeile
stehen wir das einleitende. Jedes eingeschlossene Zeilenende wird dabei zum
Bestandteil der Zeichenkette, so als hätten Sie an dieser Stelle ein
Newline-Escape-Zeichen eingebaut.

Für die Fälle, in denen das Setzen der Apostrophe oder Anführungszeichen zu
umständlich erscheint, bietet Perl die sogenannten indexterm:[Quote]
``Quote-Operatoren'' an, die ebenfalls literale Zeichenketten definieren:

* `q(Hallo Welt)` entspricht `'Hallo Welt'`
* `qq(Hallo Welt)` entspricht `"Hallo Welt"`

Die in obigen Beispielen als Begrenzer fungierenden runden Klammern können bei
Bedarf auch durch geschweifte Klammern, den Schrägstrich `/`, das
Nummernzeichen `#`, den Klammeraffen `@`. So kann man Konflikte mit in der
Zeichenkette enthaltenen Zeichen vermeiden.

Eine Zeichenkette, die keine Zeichen enthält, verdient zwar ihren Namen nicht
so recht, ist aber durchaus valides Perl. Sie kann zum Beispiel in der Form
`''` geschrieben werden. Der indexterm:[Leerstring] Leerstring ist somit ein
valider Wert -- auch wenn er bei der Ausgabe auf dem Bildschirm
unsichtbar bleibt.


==== Typumwandlung

Ein einzelner, ``atomarer'' Wert kann in Perl entweder eine Zahl oder ein String sein. (Im Kapitel <a href="#cha:references" class="chapterref"></a> werden wir noch die ``Referenz'' als weiteren Typ kennenlernen, bleiben wir aber zunächst bei den ersten beiden.)

Sehr streng unterscheidet Perl diese beiden Typen nicht. Anders als bei
anderen Programmiersprachen sind sie jederzeit weitgehend austauschbar &mdash; je nachdem, in welchem Kontext ein Wert verwendet wird, wird sein Typ automatisch in die passende Alternative konvertiert. Was da genau passiert, behandeln wir etwas später.

*Übung:*

    Welche ist die einfachste Art, um die Worte ``Perl'' und
    ``Linux'' mit 3 Leerzeilen Zwischenraum auszugeben?


==== Logische Werte

<a name="idx:Logische Werte">Logische Werte</a> sind die Grundlage von
Entscheidungen, die innerhalb eines Programms gefällt werden müssen.  Es gibt
nur zwei logische Werte: ``wahr'' und ``falsch''. Sie können
sie auch als ``Ja'' und ``Nein'' interpretieren.

Hängt zum Beispiel der Programmablauf davon ab, ob eine Variable den Wert 0
enthält, programmieren Sie eine entsprechende Prüfung, deren Ergebnis entweder
``wahr'' ist (Variablenwert ist 0) oder ``falsch'' (Variablenwert ist ungleich 0). Aufgrund dieses Ergebnisses entscheidet das Programm
anschließend, wie es weiterarbeiten soll.

In anderen Programmiersprachen gibt es für die beiden Möglichkeiten die Werte `TRUE` und `FALSE`, Perl jedoch kennt für diese Werte keine
spezielle Syntax. In Perl wird ``wahr'' durch die Zahl 1 dargestellt,
für ``falsch'' steht der Zustand `undef`.

Umgekehrt ordnet der Perl-Interpreter allen Zahlen und Zeichenketten eine Bedeutung als logische Werte zu. Interpretiert er eine Zahl als logischen
Wert, so entspricht der Wert 0 dem Wert ``falsch'', alle anderen
Zahlen stehen für ``wahr''. Als ``wahr'' werden auch alle
nicht-leeren Zeichenketten interpretiert, lediglich der Leerstring `""` wird als ``falsch'' interpretiert. Dadurch
können Sie jeden beliebigen Wert als logischen Wert verwenden, um zum Beispiel
eine Bedingung zu formulieren.


<h2 id="sec:ausdrücke">Ausdrücke</h2>

Jedes Sprachkonstrukt, dem ein Wert zugeordnet werden kann, wird als
<q><a name="idx:Ausdruck">Ausdruck</a></q> bezeichnet. Die einfachsten Ausdrücke sind Literale, das sind ausgeschriebene Zahlen oder Zeichenketten. Ihr Wert ist sofort ersichtlich; dass `153` den Wert 153 hat, liegt auf der Hand. 

Beliebig komplexe Ausdrücke entstehen durch die Verknüpfung von Ausdrücken durch Operatoren. Ein Beispiel hierfür sind die Grundrechenarten: die
Verknüpfung der Ausdrücke `3` und `7` durch den
Additionsoperator `+` ergibt einen Ausdruck mit dem Wert 10. Mit anderen (verständlicheren) Worten: der Wert des Ausdrucks `3+7` ist 10.

Auch die meisten im Sprachkern von Perl eingebauten Anweisungen erzeugen
bei ihrer Ausführung einen Wert, der vom Programm als Ausdruck verstanden
wird. Eine Anweisung, deren Hauptzweck darin liegt, einen solchen Wert zu
erzeugen, wird auch als <q><a name="idx:Funktion">Funktion</a></q>
bezeichnet. Diesen Begriff kennen Sie wahrscheinlich ebenfalls aus der
Mathematik, zum Beispiel von der Sinus-Funktion, deren Wert abhängig vom
verarbeiteten Winkel irgendwo zwischen -1 und +1 liegt. Wie bei der
Sinus-Funktion gibt es auch in Perl Funktionen, die einen oder mehrere
Eingangswerte, so genannte ``Argumente''<a name="idx:Argument"></a>
oder <q><a name="idx:Parameter">Parameter</a></q>, entgegennehmen und
daraus ein Ergebnis ermitteln. Wie Sie zusätzlich zu den vordefinierten eigene
Funktionen programmieren können, lernen Sie in einem späteren Kapitel.



=== Variablen

Für die Daten, die ein Perl-Programm verarbeiten soll, benötigt es passende
Speicherplätze. Das Programm legt in ihnen Werte ab, liest diese wieder heraus
und kann sie auch verändern oder löschen. Deshalb wird ein solcher
Speicherbereiche als <q><a name="idx:Variable">Variable</a></q> bezeichnet. Jede Variable ist durch einen <a name="idx:Bezeichner">Bezeichner</a> eindeutig zu identifizieren; anders gesagt: jede Variable hat einen Namen.

<div class="exercise">
  <h4>Übung</h4>
  Kennen Sie die Regeln für Bezeichner noch? Schauen Sie noch einmal weiter vorn nach. 
</div>



==== Variablentypen<a name="sub:variablentypen"></a>

Es gibt in Perl drei grundlegend unterschiedliche Arten von Variablen:
<a name="idx:Skalar">Skalar</a>, <a name="idx:Array">Array</a> und <a name="idx:Hash">Hash</a>.

Ein einzelner Wert, sei es nun eine Zahl oder eine Zeichenkette, wird als
``Skalar'' bezeichnet. Eine Variable, die einen Skalar speichern kann,
wird daher als ``skalare Variable''<a name="idx:Variable!skalare"></a>
bezeichnet.

Man kann sich eine skalare Variable als eine Schublade vorstellen (wobei wir im Folgenden immer davon ausgehen werden, dass eine Schublade stets nur einen einzelnen Wert enthalten kann):

<div class="figure" id="fig:scalar">
  <img src="graphics/scalar.png" width="50%" />
  <p class="caption">Bildliche Darstellung einer skalaren Variablen
</div>

<pre><code class="example">$string = "Hallo Welt!";
print $string;
</code></pre>

In diesem Beispiel wird einer skalaren Variablen, deren Namen immer ein Dollarzeichen vorangestellt wird, ein Wert in Form einer Zeichenkette zugewiesen. In der folgenden Anweisung wird der Inhalt der Variablen &mdash; eben die vorige Zeichenkette &mdash; auf den Bildschirm ausgegeben.

Im Laufe eines Programms darf eine skalare Variable ihren Datentyp auch ändern. Sie kann an einer Stelle eine Zahl speichern und an einer anderen eine Zeichenkette. Weil das aber schnell zu Verwirrung führen kann, ist das nicht empfehlenswert.

<div class="important">

Entscheiden Sie sich einmal für den Typ, den eine skalare Variable haben
soll, und bleiben Sie dabei.

</div>

Ein skalarer Speicherplatz, dem noch kein Wert &mdash; weder eine Zahl noch eine Zeichenkette &mdash; zugeordnet wurde, ist in undefiniertem Zustand. Die Funktion `defined` liefert einen logischen Wert, der anzeigt, ob ihr Parameter definiert ist oder nicht.

Zusätzlich zu den Skalaren gibt es noch zwei Variablenarten, die unter einem Namen beliebig viele skalare Werte zusammenfassen können.  Wir werden sie in Kapitel <a href="#cha:complexdata" class="chapterref"></a> genau unter die Lupe nehmen, sie seien aber hier schon einmal vorgestellt:

<ul>

  <li>Ein <strong>Array</strong> besteht aus einer beliebig langen Reihe
skalarer Elemente. Jedes dieser Elemente wird durch einen fortlaufenden Index
eindeutig identifiziert.</li>

  <li>Auch das <strong>Hash</strong> enthält beliebig viele skalare Werte.
Diese haben aber keine bestimmte Ordnung und werden statt durch einen Index
durch eine Zeichenkette, den so genannten Schlüssel, eindeutig
identifiziert.</li>

</ul>

Beim Zugriff auf Variablen wird dem Bezeichner immer ein Zeichen, das
sogenannte <q><a name="idx:Sigil">Sigil</a></q>, vorangestellt, das
für den <em>Typ des Ergebniswertes</em> steht:

<ul>
<li>Beim Zugriff auf skalare Werte (skalare Variable, Arrayelement,
  Hashelement): `$` vor dem Variablennamen</li>
<li>Beim Zugriff auf eine Array-Variable als Ganzes: `@` vor
  dem Variablennamen</li>
<li>Beim Zugriff auf eine Hash-Variable als Ganzes: `%` vor
  dem Variablennamen</li>
</ul>

Bei Perl-Anfängern schleicht sich leicht das Missverständnis ein, dass das Sigil den Typ der Variablen widerspiegelt. In Wirklichkeit geht es aber um den Typ des Wertes, das der Variablenzugriff ergeben wird. Symbolisiert wird also nicht der Typ der Variablen, sondern der <a class="footnote">Typ des abgerufenen Wertes<span id="fn-2" class="footnote">Inzwischen haben die Perl-Hüter eingesehen, dass das instinktive Verständnis, das Sigil mit dem Variablentyp zu verbinden, die sinnigere Ansicht ist. Perl 6 wird genau so funktionieren.</span></a>.

Ein Beispiel: Während beim Zugriff auf ein Array als Ganzes das
`@`-Zeichen eingesetzt wird, ist beim Zugriff auf einzelne Elemente
des Arrays, die immer skalar sind, das Dollarzeichen angebracht.



==== Zuweisung von Werten<a name="sub:zuweisung_von_werten"></a>

Um einer Variablen einen Wert zuzuweisen, wird der <a
name="idx:Zuweisungsoperator">Zuweisungsoperator</a><a
name="idx:Operator!Zuweisungs-"></a> `=`
eingesetzt. Dabei wird links des Operators die Variable genannt und rechts der
Ausdruck, dessen Wert die Variable annehmen soll.

<pre><code class="example">$name = "Jochen";
$alter = 36;
</code></pre>

Ein Skalar, der bereits einen Wert trägt, kann wieder in den undefinierten
Zustand versetzt werden, indem Sie ihm den Pseudowert
<span class="literal"><a name="idx:undef">undef</a></span> zuweisen.

Diesen und weitere Zuweisungsoperatoren werden wir später noch ausführlich
kennenlernen.

<div class="exercise">
    <h4>Übung</h4>
    Schreiben Sie ein kleines Programm, das einer Variablen einen
  zweizeiligen Text zuweist und diese dann ausgibt.

</div>



==== Zugriff auf Variablen
<a name="sub:zugriff_auf_variablen"></a>

Überall, wo innerhalb eines Ausdrucks eine Variable auftaucht, wird an dieser
Stelle ihr Wert eingesetzt, bevor der Ausdruck ausgewertet wird:

<pre><code class="example">$a = 3;
$b = 5;
$c = $a + $b;     # $c erhält den Wert 8
</code></pre>

Innerhalb Zeichenketten, die durch Anführungszeichen begrenzt sind, werden
Variablen ebenfalls interpoliert, d.h. durch ihre Werte ersetzt:

<pre><code class="example">$name = 'Margit';
$gruss = "Hallo $name!";
</code></pre>

Weil auf diese Weise aber schnell der Überblick verloren geht, was Variable
und was Text ist, rate ich von dieser Vermischung ab. Es gibt besser lesbare
Möglichkeiten, Variableninhalte in Zeichenketten einzubauen, allem voran den
weiter unten erklärten Verkettungsoperator.

Bei Zeichenketten, die durch Apostrophe begrenzt sind, werden Variablen
grundsätzlich nicht interpoliert. Dies bringt, zusammen mit dem Ignorieren der
Escape-Zeichen, dieser Schreibweise einen kleinen Geschwindigkeitsvorteil.
Wichtiger ist aber, dass hier das Dollarzeichen und der Backslash als ganz
normale Zeichen behandelt werden. Wenn Sie also verhindern wollen, dass diese
Zeichen unerwünschte Sonderfunktionen auslösen, verwenden Sie Apostrophe.



==== Geltungsbereich<a name="sub:geltungsbereich"></a>

Jede Variable hat eine bestimmte <a name="idx:Lebensdauer">Lebensdauer</a>.
Dieser reicht von ihrer Erzeugung bis hin zu dem Punkt, an dem sie vernichtet
und ihr Speicherbereich wieder zur Nutzung frei gegeben wird. Während dieser
Lebensdauer der Variablen &mdash; man spricht von ihrem &quot;<a
name="idx:Geltungsbereich">Geltungsbereich</a>&quot; &mdash; kann über
ihren Namen auf ihren Inhalt zugegriffen werden.

Im einfachsten Fall wird eine Variable dann erzeugt, wenn sie zum ersten Mal
im Programm benutzt wird, und vernichtet, wenn das Programm endet. Beides
passiert automatisch. Der Geltungsbereich von Variablen ist somit von Haus aus
das gesamte Programm; man spricht von &quot;globalen
Variablen&quot;<a name="idx:Globale Variable"></a><a name="idx:Variable!globale"></a>.

In anderen Programmiersprachen muss die Einführung einer neuer Variablen
speziell angekündigt werden, Perl erledigt das einfach bei Bedarf.

<pre><code class="example"># Programmstart
...
# Variable "x" existiert bisher noch nicht
...
$x = 100;
# Variable "x" existiert jetzt
# und speichert den Wert 100
...
# Programmende; alle Variablen werden vernichtet
</code></pre>

Perl tut offensichtlich alles, um uns das Arbeiten mit Variablen so einfach
wie möglich zu machen. &quot;Ein neuer Variablen-Bezeichner? Ach, erzeugen
wir einfach eine passende Variable!&quot; Das bedeutet aber auch, dass ein
Tippfehler im Variablennamen nicht zu einer Fehlermeldung führt, sondern zur
Geburt einer neuen Variable und zu einem unvorhergesehenen Verhalten unseres
Programms. Es ist daher besser, wenn wir den Eifer unserer Programmiersprache
von vornherein etwas dämpfen. Etwas weiter unten lernen Sie, wie das geht.

Innerhalb ihres Geltungsbereichs und Datentyps sind Variablennamen
eindeutig. Das heisst: innerhalb des gleichen Geltungsbereiches kann es keine
zwei skalare Variablen mit dem Namen `$adresse`
geben.

Der Datentyp ist jedoch ein Unterscheidungsmerkmal. Deshalb ist die
parallele Existenz einer skalaren Variablen <span
class="literal">$preis</span> und einer Array-Variablen <span
class="literal">@preis</span> möglich. Dass so etwas nicht zur
Verständlichkeit eines Programms beiträgt, liegt hoffentlich auf der Hand!

Dabei muss aber ganz klar gesagt werden: Globale Variablen begünstigen
Programmierfehler und verursachen mehr Aufwand bei der Entwicklung! Sobald ein
Programm mehr als ein paar Zeilen hat, wird es Ihnen schwer fallen, zu
überblicken, welche Bezeichner schon für Variablen verwendet wurden. Wollen
Sie zum Beispiel ein Programm, das Sie schon lange nicht mehr gewartet oder
gar frisch von einem anderen Entwickler geerbt haben, an einer kleinen Stelle
erweitern und dabei eine neue Variable hinzufügen, können Sie die Folgen
dieser Änderung kaum absehen. Sollte nämlich der Bezeichner, für den Sie sich
entschieden haben, wider Erwarten im Programm doch bereits benutzt werden,
werden Sie unter Umständen unerwartete Ergebnisse erhalten.

<div class="important">

<a class="footnote">Geltungsbereich bedeutet Wirkungsbereich<span id="fn-3" class="footnote">Jedenfalls in den meisten Fällen.</span></a>.

</div>

Es ist mühsam, jedes Mal den gesamten Quelltext nach Variablennamen zu durchforsten. Ideal ist es deshalb, wenn der Geltungsbereich &mdash; und damit der Wirkungsbereich &mdash; von Variablen so klein wie möglich ist. Und weil Perl praxisgerecht ist, bietet es auch die nötigen Mittel, um den Geltungsbereich einer Variablen einzuschränken. Diese ist dann nur noch in bestimmten, eingegrenzten Teilen des Programms bekannt und zugänglich. Man spricht von einer ``lokalen Variablen''<a name="idx:Lokale Variable"></a><a name="idx:Variable!lokale"></a>.

Wie lautet denn die Syntax für lokale Variablen? Schaut man sich in der
Perl-Dokumentation um, stößt man auch schnell auf das Schlüsselwort <span
class="literal">local</span><a name="idx:local"></a>, das vielversprechend
aussieht. Machen wir mal einen Versuch!

<pre><code class="example">#!/usr/bin/perl

$myvar = 10;
print "myvar: $myvar\n";

{
	local $myvar = 20;
	print "myvar: $myvar\n";
}

print "myvar: $myvar\n";
</code></pre>

Und tatsächlich scheint `local` genau die gewünschte Wirkung zu
erzielen:

<pre><code class="shell">$> perl local1.pl
myvar: 10
myvar: 20
myvar: 10
</code></pre>

Innerhalb des Blocks, in dem die Variable als lokal deklariert wurde, kann sie
tatsächlich einen anderen Wert annehmen als im umliegenden Programm.

Wenn wir jedoch Perl ein wenig in die Karten schauen, stellen wir fest, dass
`local` nicht der Weisheit letzter Schluss ist. Der Interpreter macht
hier nicht mehr als bei der `local`-Anweisung den alten Wert der
betreffenden Variablen in einem Zwischenspeicher zu sichern, um ihn
schließlich nach der letzten Zeile des aktuellen Blocks wieder zu
restaurieren. Es handelt sich also nicht um eine neue Variable mit geringem
Geltungsbereich, sondern um die alte, globale &mdash; nur mit einem temporär
veränderten Wert! Diese Veränderung wird beim Verlassen des Blocks, in dem
`local` eingesetzt wurde, rückgängig gemacht.

Nun werden wir etwas später aber lernen, wie man mitten aus einem Block
heraus die Abarbeitung eines ganz anderen Blocks, eines so genannten
``Unterprogramms'', auslösen kann. Weil <span
class="literal">local</span> nur den Wert einer Variablen ändert, aber nichts
daran, dass sie global im gesamten Programm existiert, können wir damit auch
nicht verhindern, dass ein Unterprogramm auf die Variable zugreift. Welchen
Wert wird sie dort aber enthalten? Klar: den temporären Wert unserer nur
vermeintlich lokalen Variable! Denn ihr ursprünglicher Wert wird schließlich
erst am Ende des `local`-Blocks wiederhergestellt,
und das wurde in diesem Szenario noch nicht erreicht.

Was wir eigentlich benötigen, ist eine Variable, die nicht nur übergangsweise
einen anderen Wert annehmen kann, sondern deren Lebensdauer wirklich auf einen
Block beschränkt ist, die wirklich nur in diesem Block ``lebt'': Nur
innerhalb dieses Blocks darf die Variable bekannt und ihr Inhalt zugänglich
sein.

Und natürlich kennt Perl solche Variablen; sie werden als
``lexikalische Variablen''<a name="idx:Lexikalische Variable"></a><a
name="idx:Variable!lexikalische"></a> bezeichnet. Wir müssen an unserem
Programm nicht einmal viel ändern, sondern einfach <span
class="literal">local</span> durch das Schlüsselwort <span
class="literal">my</span><a name="idx:my"></a> ersetzen. Das Ergebnis sehen
Sie in Listing <a href="#lst:local2.pl" class="listref"></a>.

<div class="listing" id="lst:local2.pl">
<pre><code>#!/usr/bin/perl

$myvar = 10;
print "myvar: $myvar\n";

{
	my $myvar;
	$myvar = 20;
	print "myvar: $myvar\n";
}

print "myvar: $myvar\n";
</code></pre>
<p class="caption">Einsatz lexikalischer Variablen
</div>

Eine lexikalische Variable ist wirklich nur innerhalb der geschweiften Klammern bekannt, die den Teil des Programms mit der `my`-Deklaration umschließen. Anderswo im Programm wird der Zugriff mit ihrem Bezeichner nie zu dieser Variable, sondern höchstens zu einer anderen Variable des gleichen Namens führen, die dort heimisch ist.

<div class="important">
  Das automatische Erzeugen neuer Variablen erschwert die Vermeidung
  logischer Fehler und deshalb unterbinden wir es am besten von
  vornherein für das gesamte Programm.
</div>

Dazu reicht die Anweisung `use strict;` am Beginn des Programms. Nach
diesem <a name="idx:Pragma">Pragma</a> &mdash; so nennt man Anweisungen, die das Verhalten des
Perl-Interpreters beeinflussen &mdash; wird der Perl-Interpreter jede Variable, die
nicht mittels `my` eingeführt wurde, mit einer Fehlermeldung ablehnen
und das Programm abbrechen.

Und weil sich `use strict;` hervorragend mit `use warnings;`
versteht, empfehle ich Ihnen, jedes Ihrer Programme mit folgenden Zeilen zu
beginnen:

<pre><code class="example">#!/usr/bin/perl
#
# Kurzbeschreibung des Programms

use strict;
use warnings;
</code></pre>

Mit diesen beiden Pragmata verhindern Sie zahlreiche Probleme, die durch
Unachtsamkeit, fehlenden Überblick oder Tippfehler entstehen.

Wohlgemerkt kann auch eine lexikalische Variable global sein, nämlich dann,
wenn ihre Deklaration nicht von einem Block umgeben ist:

<pre><code class="example">#!/usr/bin/perl

my $pi = 3.1416; # global

{
    my $radius = 10;                # lokal
    my $umfang = 2 * $pi * $radius; # lokal

    print "Radius: ", $radius, 
      " Umfang: ", $umfang, "\n";
}

# hier ist nur noch $pi bekannt
</code></pre>



=== Operatoren<a name="sec:operatoren"></a>

Ein <a name="idx:Operator">Operator</a> verknüpft Werte und erzeugt aus ihnen einen
Ergebniswert. Sie kennen Operatoren bereits aus der ersten Schulklasse: der
Operator `+` verknüpft zwei Werte und liefert als Ergebnis den Wert
ihrer Addition. Perl kennt eine Vielzahl von Operatoren, die allesamt einen,
zwei oder gar drei Werte, die ``Operanden'', verknüpfen und aus ihnen
einen Ergebniswert ermitteln. Abhängig von der Zahl ihrer Operanden bezeichnet
man Operatoren als ``unär'', ``binär'' oder ``ternär''.

In den folgenden Abschnitten werden die verschiedenen Gruppen von Operatoren,
die Perl kennt, beschrieben.



==== Arithmetische Operatoren

<a name="idx:Arithmetische Operatoren">Arithmetische Operatoren</a><a name="idx:Operator!arithmetisch"></a> kennen Sie aus
dem Mathematikunterricht in der Grundschule. Die Grundrechenarten sind zum
Beispiel arithmetische Operationen. Hinzu kommen der Potenzoperator und der
<a name="idx:Modulo-Operator">Modulo-Operator</a><a name="idx:Operator!Modulo-"></a>, der den Rest bei einer
ganzzahligen Division ermittelt.

<table>
    
    <thead>
        <tr>
            <th>Operation</th>
            <th>Bedeutung</th>
        </tr>
    </thead>
    
    <tbody>
        
        <tr>
            <td>`$a + $b`</td>
            <td>Addition</td>
        </tr>

        <tr>
            <td>`$a - $b`</td>
            <td>Subtraktion</td>
        </tr>

        <tr>
            <td>`$a * $b`</td>
            <td>Multiplikation</td>
        </tr>
    
        <tr>
            <td>`$a / $b`</td>
            <td>Division</td>
        </tr>
    
        <tr>
            <td>`$a ** $b`</td>
            <td>Potenz</td>
        </tr>
    
        <tr>
            <td>`$a % $b`</td>
            <td>Modulo (Rest bei der Division)</td>
        </tr>
    
    </tbody>
    
</table>


==== Zuweisungsoperatoren

Das Gleichheitszeichen haben wir bereits als
<a name="idx:Zuweisungsoperator">Zuweisungsoperator</a><a name="idx:Operator!Zuweisungs-"></a> kennengelernt. Bei
der Zuweisung wird zuerst der Ausdruck auf der rechten Seite ausgewertet und
das Ergebnis dann in der Variablen auf der linken Seite gespeichert.

<pre><code class="example">$username = "geewiz";
$op1 = 14;
$op2 = 211;
$summe = $op1 + $op2;
</code></pre>

Die Zuweisung ist ebenfalls ein Ausdruck; der zugewiesene Wert der
rechten Seite ist gleichzeitig der Wert der Zuweisung als Ganzes.

Oft taucht die auf der linken Seite verwendete Variable auch rechts
wieder auf, weil ihr neuer Wert aus dem alten Wert ermittelt wird.
Zum Beispiel wird auf eine Summenvariable immer wieder ein neuer Wert
aufaddiert:

<pre><code class="example">$sum = $sum + $item;
</code></pre>

Um solche Ausdrücke kürzer schreiben zu können, wurden zusätzliche
Zuweisungsoperatoren aus der Programmiersprache C übernommen:

<pre><code class="example">$var += 2;   # entspricht $var = $var + 2;
$var -= 2;   # entspricht $var = $var - 2;
$var *= 2;   # entspricht $var = $var * 2;
$var /= 2;   # entspricht $var = $var / 2;
</code></pre>



==== Inkrement-/Dekrement-Operatoren

Zählen gehört zu den häufigsten Aufgaben innerhalb einer Software,
seien es die Zeilen einer Datei, die Zahl aufgezeichneter Basenpaare
oder die Worte eines Schulungsbuchs.

Deshalb hat Larry Wall seiner Programmiersprache spezielle Operatoren
hinzugefügt, die Variablenwerte um 1 erhöhen oder verringern.

<pre><code class="example">$var++;   # entspricht $var += 1;
$var--;   # entspricht $var -= 1;
</code></pre>

Es handelt sich dabei sichtlich um ``unäre Operatoren'' &mdash; sie
beziehen sich auf den Bezeichner der zu verändernden Variable und benötigen
keinen weiteren Operanden. Der Operator, der eine Variable um 1 erhöht, heißt
<q><a name="idx:Inkrement-Operator">Inkrement-Operator</a></q><a
name="idx:Operator!Inkrement-"></a>, der gegenteilige heißt &quot;<a
name="idx:Dekrement-Operator">Dekrement-Operator</a>&quot;<a
name="idx:Operator!Dekrement-"></a>.

Wie alle Operatoren bilden auch die Inkrement-/Dekrement-Operatoren einen
Ausdruck. Dabei stellt sich aber die folgende Frage: ermittelt sich der Wert
des Ausdrucks nun aus dem Zustand der Variablen vor der Veränderung oder dem
nach der Veränderung? Betrachten wir zum Beispiel folgendes Beispiel:

<pre><code class="example">$a = 5;
$doppelt = $a++ * 2;
</code></pre>

Wird `$doppelt` den Wert 10 oder 12 enthalten?

Die Erfahrung zeigt, dass in der Praxis keine Alternative der anderen
überlegen ist. Daher gibt es von diesem Operator eine Variante, die <em>zuerst
die Variable verändert</em> und dann ihren (neuen) Wert liefert, und eine, die
erst ihren Wert ermittelt und <em>die Variable erst danach verändert</em>.
Entsprechend steht der Operator dabei einmal <em>vor dem Bezeichner</em> und
einmal <em>nach dem Bezeichner</em>.

<pre><code class="example">$a = 5;
$doppelt = ++$a * 2;
# $a ist jetzt 6, $doppelt ist 12 

$a = 5;
$doppelt = $a++ * 2;
# $a ist jetzt 6, $doppelt ist 10 
</code></pre>



==== Vergleichsoperatoren

<a name="idx:Vergleich"></a>Wo immer Daten verarbeitet werden, werden sie
untereinander verglichen. Und auf Basis dieser Vergleiche werden dann
Entscheidungen über die weitere Verarbeitung getroffen.

Perl steuert zu diesem Zweck <a
name="idx:Vergleichsoperatoren">Vergleichsoperatoren</a><a
name="idx:Operator!Vergleichs-"></a> bei, die einen logischen Wert annehmen,
der den Ausgang des Vergleichs darstellt (``ist kleiner als'',
``ist größer oder gleich'', usw.).

Zahlen zu vergleichen fällt Perl ähnlich leicht wie uns Menschen. Zu
entscheiden, welche von zwei Zahlen die größere ist &mdash; vorausgesetzt, sie
sind nicht gleich &mdash; erfordert nicht viel Diskussion.

Zeichenketten werden immer zeichenweise von links her so lange verglichen,
bis eine Entscheidung möglich ist. Verglichen werden die Zeichencodes,
innerhalb derer Ziffern und Buchstaben natürlich in der gewohnten Reihenfolge
auftreten. Sobald sich beim Vergleich zweier Zeichen ein Unterschied ergibt,
bestimmt dieser das Ergebnis des Vergleichs. Wurden alle Zeichen verglichen,
ohne dass sich ein Unterschied ergab, sind beide Zeichenketten offensichtlich
gleich. Bleiben von einer der beiden Zeichenketten noch Zeichen übrig, wird
sie als größer betrachtet. Durch dieses Verfahren entsteht aber folgende
skurrile Situation:

<ul>

<li>`1`  ist kleiner als `2`. Klar.</li>

<li>`10` ist größer als `2`. Auch hier gilt unsere
Schulmathematik.</li>

<li>`"1"` ist kleiner als `"2"`, weil auch im Zeichencode die
1 vor der 2 kommt.</li>

<li>`"10"` ist <strong>kleiner</strong> als `"2"`! Da schon die
jeweils ersten Zeichen unterschiedlich sind, wird auch bereits hier der
Vergleich mit der Erkenntnis des vorangehenden Punkts beendet.</li>

</ul>

Was passiert denn aber nun, wenn ich eine Zahl mit einer Zeichenkette
vergleiche &mdash; vor allem angesichts der automatischen Datenwandlung des
Interpreters? Um hier Eindeutigkeit zu schaffen, hat man Perl gleich zwei
Sätze von Vergleichsoperatoren verliehen &mdash; einen für Zahlen, einen für
Strings:

<table>
    <thead>
        <tr>
            <th>Vergleich von Zahlen</th>
            <th>Vergleich von Strings</th>
            <th>Bedeutung</th>
        </tr>
    </thead>
    
    <tbody>
        
        <tr>
            <td>`==`</td>
            <td>`eq`</td>
            <td>ist gleich</td>
        </tr>
                
        <tr>
            <td>`!=`</td>
            <td>`ne`</td>
            <td>ist ungleich</td>
        </tr>
                
        <tr>
            <td>`&lt;`</td>
            <td>`lt`</td>
            <td>ist kleiner als</td>
        </tr>
                
        <tr>
            <td>`&gt;`</td>
            <td>`gt`</td>
            <td>ist größer als</td>
        </tr>
                
        <tr>
            <td>`&lt;=`</td>
            <td>`le`</td>
            <td>ist kleiner oder gleich</td>
        </tr>
                
        <tr>
            <td>`&gt;=`</td>
            <td>`ge`</td>
            <td>ist größer oder gleich</td>
        </tr>

    </tbody>
</table>


==== Auswahloperator <a name="sub:auswahloperator"></a>

Der <a name="idx:Auswahloperator">Auswahloperator</a><a name="idx:Operator!Auswahl-"></a> ist der einzige ``ternäre Operator''<a name="idx:Operator!ternärer"></a> in Perl, also der einzige Operator, der drei Operanden hat. Der erste Operator ist dabei ein logischer Ausdruck in runden Klammern, dem ein Fragezeichen und zwei durch einen Doppelpunkt getrennte beliebige Ausdrücke folgen.

<pre><code class="example">( $a == $b ) ? "gleich" : "ungleich"
</code></pre>

Der Wert der Operation hängt nun von dem logischen Ausdruck ab: hat
dieser den Wert ``wahr'', nimmt der Gesamtausdruck den Wert des
zweiten Operanden an, ansonsten den des dritten.

Somit macht es der Auswahloperator möglich, von Bedingungen abhängige
Ausdrücke zu formulieren.

<!-- TODO
	Klammerung nötig:
	
	print ((...) ? ... : ...)
-->

==== Logische Operatoren

Um logische Ausdrücke zu komplexeren, wiederum logischen Ausdrücken zusammensetzen zu können, brauchen wir logische Operatoren<a name="idx:Logischer Operator"></a><a name="idx:Operator!logischer"></a>. Diese werden durch die so genannte <q><a name="idx:Boolesche Algebra">Boolesche Algebra</a></q> definiert, benannt nach dem Mathematiker Boole. Sie kennt als Operationen die <a name="idx:Und-Verknüpfung">Und-Verknüpfung</a> (<q><a name="idx:AND">AND</a></q>), die <a name="idx:Oder-Verknüpfung">Oder-Verknüpfung</a> (<q><a name="idx:OR">OR</a></q>), die <a name="idx:Exklusiv-Oder-Verknüpfung">Exklusiv-Oder-Verknüpfung</a> (<q><a name="idx:XOR">XOR</a></q>) sowie die <a name="idx:Negation">Negation</a> (<q><a name="idx:NOT">NOT</a></q>). Mit Ausnahme der Negation wird bei jeder dieser Operationen mit zwei Werten gearbeitet.

Die Negation hat nur einen Operanden, dessen Wert logisch ins
Gegenteil verkehrt wird. Ist der Operand also der Zahlenwert 0, die
leere Zeichenkette `""` oder `undef`, so ergibt die
Negation den Wert 1 (logisch ``wahr''). Die Negation aller anderen
Werte ergibt einen Nullwert.

Die AND-Verknüpfung ist nur dann ``wahr'', wenn auch beide
Operanden ``wahr'' sind. Perl kennt für diese Operation den
Operator `&amp;&amp;`.

<table>
    <thead>
        <tr>
            <th>AND</th>
            <th>wahr</th>
            <th>falsch</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="col1">wahr</td>
            <td>wahr</td>
            <td>falsch</td>
        </tr>
        <tr>
            <td class="col1">falsch</td>
            <td>falsch</td>
            <td>falsch</td>
        </tr>
    </tbody>
</table>

Bei der OR-Verknüpfung, in Perl durch den Operator `||`
symbolisiert, reicht es, wenn einer der beiden Operanden
``wahr'' ist:

<table>
    <thead>
        <tr>
            <th>OR</th>
            <th>wahr</th>
            <th>falsch</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="col1">wahr</td>
            <td>wahr</td>
            <td>wahr</td>
        </tr>
        <tr>
            <td class="col1">falsch</td>
            <td>wahr</td>
            <td>falsch</td>
        </tr>
    </tbody>
</table>


Die XOR-Verknüpfung (Operator: `^`) erwartet, dass nur einer der beiden Operanden ``wahr'' ist:

<table>
    <thead>
        <tr>
            <th>XOR</th>
            <th>wahr</th>
            <th>falsch</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="col1">wahr</td>
            <td>falsch</td>
            <td>wahr</td>
        </tr>
        <tr>
            <td class="col1">falsch</td>
            <td>wahr</td>
            <td>falsch</td>
        </tr>
    </tbody>
</table>

Perl hat auch hier zwei Sätze von Operatoren. Beim einen werden die Operatoren durch Sonderzeichen dargestellt, beim anderen sind es die englischsprachigen Bezeichnungen, die oben bereits genannt wurden. Der Unterschied liegt in der Rangfolge innerhalb der Menge der Operatoren: die erstgenannten Varianten haben einen sehr hohen Rang, diese Operationen werden also schon sehr früh ausgewertet; die ausgeschriebenen Operatoren hingegen liegen in der Rangfolge sehr weit hinten und lassen den meisten anderen Operationen den Vortritt. Diese Unterscheidung erspart uns oftmals das Einklammern von Teilausdrücken.



<a name="sub:logischer_kurzschluss">==== Logischer Kurzschluss</a>

In C liefern die logischen Operatoren auch tatsächlich reine Wahrheitswerte, nämlich 0 oder 1. Perl macht es sich hier einfacher. Das Ergebnis der logischen Verknüpfung wird in Perl nämlich durch ein sogenanntes ``Kurzschlussverfahren''<a name="idx:Logischer Kurzschluss"></a> ermittelt. Dabei macht man sich die Tatsache zunutze, dass sowohl bei AND als auch bei OR in einer der beiden Spalten der Wert des zweiten Operanden erhalten bleibt. Und so gilt in Perl schlicht und einfach:

<ul>
<li>Ist bei der AND-Verknüpfung der erste Operand logisch ``wahr'',
  ergibt die Operation den Wert des zweiten Operanden, ansonsten den
  des ersten.</li>
<li>Ist bei der OR-Verknüpfung der erste Operand logisch ``falsch'',
  ergibt die Operation den Wert des zweiten Operanden, ansonsten den
  des ersten.</li>
</ul>

So lange Sie mit reinen logischen Werten (also 0 oder 1) arbeiten, entspricht dieses Verhalten exakt den oben dargestellten Tabellen.

Flexibel, wie Perl ist, dürfen die Werte der Operanden jedoch beliebige Ausdrücke sein. Da es klare Regeln gibt, welche Werte als logisch ``falsch'' angesehen werden (nämlich 0, die leere Zeichenkette und `undef`; siehe Kapitel <a href="#sub:logische_werte" class="pageref"></a>), werden die Operanden bei der Verknüpfung nicht in logische Werte umgewandelt, sondern nur als solche interpretiert. Es ergibt sich aus der Verknüpfung also einer der Originalwerte der Operanden.

<div class="exercise">
    <h4>Übung</h4>
	Welche Werte haben die folgenden Ausdrücke?
	
	<ul>
		<li>`0 and 1`</li>
		<li>`'x' or 'u'`</li>
		<li>`1 and 0`</li>
		<li>`0 or 'NULL'`</li>
	</ul>
</div>

Das ermöglicht es uns zum Beispiel, ganz einfach einer Variablen einen
Standardwert zuzuweisen, falls sie noch leer ist. `undef` wird
bekanntlich als ``falsch'' gewertet, sodass wir uns das eben beschriebene
Verhalten der OR-Verknüpfung zunutze machen können:

<pre><code class="example">$a = $a || 'vormals undefiniert';

# kuerzer:
$a ||= 'vormals undefiniert';
</code></pre>

Perl in seiner nahezu grenzenlosen Flexibilität erlaubt es uns außerdem,
Anweisungen als Operanden einzusetzen. Für Perl hat jede Anweisung einen Wert
(im Zweifel den Wert ``wahr''), sodass sie in Ausdrücken, auch in
logischen, eingesetzt werden darf.

Oben beschriebene Logik, nach der Perl zunächst den linken Operanden
betrachtet und dann entscheidet, ob der rechte überhaupt noch interessant ist,
eröffnet uns die Möglichkeit, Anweisungen bedingt auszuführen, ohne eine dafür
ausgelegte Anweisung zu benutzen.

Bei der AND-Verknüpfung spielt der rechte Operand nur dann eine Rolle, wenn
der linke den Wert ``wahr'' hat; ansonsten steht das Ergebnis der
Operation schon fest &mdash; ``falsch''. Der Perl-Interpreter ist schlau
genug, den zweiten Operanden also nur dann auszuwerten, wenn der erste
``wahr'' ist.

Umgekehrt wird Perl den rechten Operanden einer OR-Verknüpfung nur dann
auswerten, wenn der linke ``falsch'' ist, denn nur dann hängt das
Ergebnis vom rechten Operanden ab.

Und jetzt kommt der Trick: setzen wir als linken Operanden einen logischen
Ausdruck, als rechten Operanden aber eine Anweisung ein, hängt deren
<em>Ausführung</em> vom linken Operanden, der Bedingung, ab: bei AND wird die
Anweisung nur ausgeführt, wenn sie ``wahr'' ist, und bei der
OR-Verknüpfung führt nur ein ``falsch'' zur Ausführung der Anweisung.

<pre><code class="example">( $a == 1 ) &amp;&amp; print "a == 1!\n";
( $a == 1 ) || print "a != 1!\n";
</code></pre>


==== Bitbearbeitungsoperatoren

Zahlen werden im Rechner bekanntlich in Form von Bits und Bytes gespeichert.
Um auf dieser Ebene Berechnungen durchzuführen, werden Operatoren benötigt,
die einzelne Bits in einem Wert modifizieren können.

Nun sind Bits mit ihren digitalen Werten 1 und 0 nicht viel anders als
die vorhin beschriebenen logischen Werte ``wahr'' und
``falsch''.  Operationen wie die Und-Verknüpfung und ihre
Kollegen können zunächst auf einzelne Bits angewandt werden, dann aber
auch auf ganze Bitfolgen &mdash; und ein Byte ist nichts anderes als eine
Folge von 8 Bits. Es werden einfach Bit für Bit miteinander
ausgewertet.

In der Praxis geht es hauptsächlich um das Setzen und Löschen
bestimmter Bits in einem Binärwert. Es gilt, diesen Ausgangswert durch
eine logische Verknüpfung mit einem passend gewählten zweiten Wert,
der sogenannten Bitmaske, zu manipulieren.

Schaut man sich die verfügbaren logischen Operationen genauer an, findet man
schnell heraus, dass die Und-Verknüpfung mit einem 0-Bit unabhängig vom
Zustand des Ausgangsbits unweigerlich zu einem 0-Bit im Ergebnis führt. Das
betreffende Bit im Ausgangswert wird also gelöscht. Ein 1-Bit hingegen lässt
das verknüpfte Bit im Ausgangswert unverändert.

<pre><code class="example">
    01001100
AND 10000111
------------
    00000100
</code></pre>

Umgekehrt ist es mit der Oder-Verknüpfung: eine 1 führt unweigerlich zu einer 1 im Ergebnis, während eine 0 das ursprünglich Bit unverändert durchlässt.

<pre><code class="example">
     01001100
OR   10000111
-------------
     11001111
</code></pre>

Diese Bit-Operationen werden durch die Bitbearbeitungs-Operatoren<a
name="idx:Bitbearbeitungs-Operator"></a><a name="idx:Operator!Bitb
earbeitungs-"></a> `&amp;` (AND) und <span
class="literal">|</span> (OR) durchgeführt.


==== Zeichenkettenoperatoren

Die Anzahl der Operatoren für Zeichenketten<a
name="idx:Zeichenkettenoperator"></a><a
name="idx:Operator!Zeichenketten-"></a> ist sehr überschaubar. Da wäre zum
einen der <a name="idx:Verkettungsoperator">Verkettungsoperator</a><a
name="idx:Operator!Verkettungs-"></a> `.` zu
nennen, der zwei Strings zu einem zusammenschweisst:

<pre><code class="example">$name = "Jochen";
$output = "Hallo " . $name . "!\n";
print $output;
</code></pre>

Der zweite Operator ist etwas ungewöhnlicher, es gibt ihn in kaum einer
anderen Programmiersprache außer Perl. Es handelt sich um den
String-Vervielfacher `x`. Er hat als Operanden
einen String und eine Zahl n. Das Ergebnis ist eine Zeichenkette, die aus
n Wiederholungen des Eingangsstrings besteht.

<pre><code class="example">$trenner = "---8&lt;--- ";
print $trenner x 5, "\n";
</code></pre>

	
==== Rangfolge<a name="sub:rangfolge"></a>
<a name="idx:Rangfolge"></a><a name="idx:Operator!Rangfolge"></a>

Aus der Schule ist die Regel ``Punkt vor Strich'' bekannt. Sie besagt,
dass die Operatoren für Multiplikation und Division Vorrang vor denen für
Addition und Subtraktion haben.

Eine solche Rangfolge gilt für alle Operatoren einer Programmiersprache. Setzt
man Perl einen komplexen Ausdruck vor, entscheidet der Interpreter anhand der
definierten Ränge, in welcher Reihenfolge die einzelnen Operationen ausgeführt
werden. Zuerst kommen die höher rangierenden Operationen, erst danach werden
die Operatoren mit niedrigerem Rang berücksichtigt. Gleichrangige Operationen
werden der Reihe nach von links nach rechts ausgeführt.

Wie in der Mathematik kann auch in Perl-Ausdrücken durch das Setzen runder
Klammern von der vorgegebene Rangfolge von Operatoren abgewichen werden.

Die genaue Rangfolge (engl. ``precedence'') der Perl-Operatoren können
Sie der man-Page `perlop` entnehmen.


=== Gürtelprüfung

<img src="graphics/judogi.jpg" class="beltpic" width="200" />

Damit sind wir am Ende des ersten Lernabschnitts, der Sie in grundlegende
Eigenschaften von Perl eingeführt hat. Sie wissen nun, was Variablen sind und
wie Sie sie einsetzen können.

Der erste farbige Gürtel steht Ihnen zu, wenn Sie die folgenden Fragen und
Übungen erfolgreich absolvieren können. Für Schüler des 8. Kyu ist dieser
gelb.

<div class="clear">&nbsp;</div>

<div class="exercise">
    <h4>Übung</h4>

<ol>

<li>Welche Typen von Variablen gibt es, und wie unterscheiden sie sich?</li>

<li>Was müssen Sie beim Geltungsbereich von Variablen beachten, und
  wie können Sie ihn verändern?</li>

<li>Wie erklären Sie die Begriffe ``Ausdruck'' und ``Operator''?</li>

<li>Was sind die Unterschiede zwischen den Vergleichsoperatoren für Zahlen
und denen für Zeichenketten? Auf was müssen Sie hier achten?</li>

</ol>
</div>

	
<div class="exercise"><a name="exerc:expressions"></a>
<h4>Übung</h4>

Bearbeiten Sie den folgenden Ausschnitt aus einem Perl-Programm. (Für die
Nachbesprechung sind die Zeilennummern angegeben.) Geben Sie jeweils das zu
erwartende Ergebnis der Ausdrücke an.

<div class="listing">
<pre><code>01:  $a=220; $b=11; $c=8; $string1="Hallo"; 
        $string2="Welt";
02:  $ergebnis = $b * $c;
03:  $ergebnis = $b - $string2;
04:  $d = $c . $string1;
05:  $ergebnis = $b * $d;
06:  $ergebnis = $a % $c;
07:  $ergebnis = $b &amp; $c;
08:  $ergebnis = $a / ––$b;
09:  $ergebnis = $string1 . $string2;
10:  $ergebnis = $string2 x 2;
11:  $ergebnis = ($b &lt;= ($c + 2 + $b));
12:  $ergebnis = ($string1 eq $b);
13:  $b += 9;
</code></pre>
</div>

</div>


<div class="exercise">
    <h4>Übung</h4>

<ol>

	<li>Programmieren Sie einen möglichst kurzen Einzeiler, der den Text
``Hallo Welt!'' zwischen zwei Folgen von je 10 Sternchen ausgibt.</li>

	<li>Schreiben Sie ein möglichst kurzes Programm, das die Variable
`$i` zunächst auf den Wert 5 setzt und dann dreimal um 1 erhöht. Das
Ergebnis jeder Veränderung soll auf dem Bildschirm angezeigt werden.</li>

	<li>Bauen Sie eine Perl-Anweisung, die ``NULL'' auf den
Bildschirm ausgibt, wenn der Wert einer Variablen `$anzahl` gleich 0
ist. In jedem anderen Fall soll ihr Wert ausgegeben werden.</li>

</ol>
